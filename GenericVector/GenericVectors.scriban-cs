using System.Collections;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;
using System.Runtime.Serialization;
using System.Text.Unicode;

namespace GenericVector;

{{~
    load_file '_IncludeVector.scriban-cs'
~}}

// {{ VectorT }}
/// <summary>A structure encapsulating {{AmountName}} values, usually geometric vectors, and provides hardware accelerated methods.</summary>
[StructLayout(LayoutKind.Sequential), DataContract, Serializable]
public readonly partial struct {{VectorT}} : IVector<{{VectorT}}, T>, IVectorAlso<{{VectorT}}, T>, {{if element_count <= max_numeric_dimensions}}IEquatable<Vector{{element_count}}>, {{end}}ISpanFormattable
    where T : INumberBase<T>
{
    {{~ for x in 0..<element_count ~}}
    private readonly T _{{ xyzw[x] | string.downcase }};
    /// <summary>The {{ xyzw[x] }} component of the vector.</summary>
    [DataMember]
    public T {{ xyzw[x] }} => _{{ xyzw[x] | string.downcase }};
    {{~ end ~}}

    internal const int Count = {{ element_count }};

    /// <summary>Creates a new <see cref="{{ VectorXml }}" /> object whose {{ AmountName }} elements have the same value.</summary>
    /// <param name="value">The value to assign to all {{ AmountName }} elements.</param>
    public {{ Vector }}(T value) : this({{ ['value'] * element_count | array.join ', '}})
    {
    }

    {{~ for smallerVecN in min_dimensions..<element_count ~}}
    /// <summary>Creates a new <see cref="{{ VectorXml }}" /> object from the specified <see cref="Vector{{element_count}}D{T}" /> object {{ xyzw | array.offset dimensions2 | array.join ' and a ' }} component.</summary>
    /// <param name="value">The vector to use for the {{ xyzw | array.limit dimensions2 | humanize_and }} components.</param>
        {{~ for x in xyzw | slice smallerVecN element_count ~}}
    /// <param name="{{ x | string.downcase }}">The {{ x }} component.</param>
        {{~ end ~}}
    public {{ Vector }}(Vector{{smallerVecN}}D<T> value, {{ Parameters | slice smallerVecN element_count | array.join ", " }}) : this(
        {{- xyzwFormat "value." | slice 0 smallerVecN | array.concat (xyzw | slice smallerVecN element_count | array.each @string.downcase) | array.join ', ' -}}
    )
    {
    }
    {{~ end ~}}

    /// <summary>Creates a vector whose elements have the specified values.</summary>
    {{~ for x in xyzw | array.limit element_count ~}}
    /// <param name="{{ x | string.downcase }}">The value to assign to the <see cref="{{ x }}" /> field.</param>
    {{~ end ~}}
    public {{ Vector }}({{ Parameters | array.limit element_count | array.join ', ' }})
    {
        Unsafe.SkipInit(out this);

        {{~ for x in xyzw | array.limit element_count ~}}
        _{{ x | string.downcase }} = {{ x | string.downcase}};
        {{~ end ~}}
    }

    /// <summary>Constructs a vector from the given <see cref="ReadOnlySpan{T}" />. The span must contain at least {{element_count}} elements.</summary>
    /// <param name="values">The span of elements to assign to the vector.</param>
    public {{ Vector }}(ReadOnlySpan<T> values)
    {
        Unsafe.SkipInit(out this);

        ArgumentOutOfRangeException.ThrowIfLessThan(values.Length, Count, nameof(values));

        this = Unsafe.ReadUnaligned<{{ VectorT }}>(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(values)));
    }

    /// <summary>Gets a vector whose {{element_count}} elements are equal to zero.</summary>
    /// <value>A vector whose {{ AmountName }} elements are equal to zero (that is, it returns the vector <c>({{ ['0'] * element_count | array.join ',' }})</c>.</value>
    public static {{ VectorT }} Zero => new(T.Zero);

    /// <summary>Gets a vector whose {{element_count}} elements are equal to one.</summary>
    /// <value>Returns <see cref="{{ VectorXml }}" />.</value>
    /// <remarks>A vector whose {{ AmountName }} elements are equal to one (that is, it returns the vector <c>({{ ['1'] * element_count | array.join ',' }})</c>.</remarks>
    public static {{ VectorT }} One => new(T.One);

    {{~ for x in 0..<element_count ~}}
    {{
        v = ['0'] * element_count
        v[x] = '1';
        v = v | array.join ','

        v2 = ['T.Zero'] * element_count
        v2[x] = 'T.One';
        v2 = v2 | array.join ', '
    -}}
    /// <summary>Gets the vector ({{v}})).</summary>
    /// <value>The vector <c>({{v}})</c>.</value>
    public static {{ VectorT }} Unit{{ xyzw[x] }} => new({{v2}});
    {{~ end ~}}

    /// <summary>Creates a new <see cref="{{ VectorXml }}" /> object whose {{ AmountName }} elements have the same value.</summary>
    /// <param name="value">The value to assign to all {{ AmountName }} elements.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} Create(T scalar) => new(scalar);

    /// <summary>Creates a vector whose elements have the specified values.</summary>
    {{~ for x in xyzw | array.limit element_count ~}}
    /// <param name="{{ x | string.downcase }}">The value to assign to the <see cref="{{ x }}" /> field.</param>
    {{~ end ~}}
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} Create({{ wrap forEachDimension ', ' newline:false; $"T {cl}"; end }}) => new({{ wrap forEachDimension ', ' newline:false; cl; end }});

    /// <summary>Constructs a vector from the given <see cref="ReadOnlySpan{T}" />. The span must contain at least {{element_count}} elements.</summary>
    /// <param name="values">The span of elements to assign to the vector.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} Create(ReadOnlySpan<T> values) => new(values);

    /// <summary>Gets or sets the element at the specified index.</summary>
    /// <param name="index">The index of the element to get or set.</param>
    /// <returns>The the element at <paramref name="index" />.</returns>
    /// <exception cref="ArgumentOutOfRangeException"><paramref name="index" /> was less than zero or greater than the number of elements.</exception>
    public T this[int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => this.AsSpan()[index];
    }

    #region Operators
    /// <summary>Adds two vectors together.</summary>
    /// <param name="left">The first vector to add.</param>
    /// <param name="right">The second vector to add.</param>
    /// <returns>The summed vector.</returns>
    /// <remarks>The <see cref="op_Addition" /> method defines the addition operation for <see cref="{{ VectorXml }}" /> objects.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} operator +({{ VectorT }} left, {{ VectorT }} right)
    {
        {{ wrap vectorize 'left' 'right'; $"{a} + {b}"; end }}

        return new {{ VectorT }}(
            {{ wrap forEachDimension ','; $"left.{c} + right.{c}"; end }}
        );
    }

    /// <summary>Subtracts the second vector from the first.</summary>
    /// <param name="left">The first vector.</param>
    /// <param name="right">The second vector.</param>
    /// <returns>The vector that results from subtracting <paramref name="right" /> from <paramref name="left" />.</returns>
    /// <remarks>The <see cref="op_Subtraction" /> method defines the subtraction operation for <see cref="{{ VectorXml }}" /> objects.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} operator -({{ VectorT }} left, {{ VectorT }} right)
    {
        {{ wrap vectorize 'left' 'right'; $"{a} - {b}"; end }}

        return new {{ VectorT }}(
            {{ wrap forEachDimension ','; $"left.{c} - right.{c}"; end }}
        );
    }

    /// <summary>Negates the specified vector.</summary>
    /// <param name="value">The vector to negate.</param>
    /// <returns>The negated vector.</returns>
    /// <remarks>The <see cref="op_UnaryNegation" /> method defines the unary negation operation for <see cref="{{ VectorXml }}" /> objects.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} operator -({{ VectorT }} value)
    {
        return Zero - value;
    }

    /// <summary>Returns a new vector whose values are the product of each pair of elements in two specified vectors.</summary>
    /// <param name="left">The first vector.</param>
    /// <param name="right">The second vector.</param>
    /// <returns>The element-wise product vector.</returns>
    /// <remarks>The <see cref="{{ VectorXml }}.op_Multiply" /> method defines the multiplication operation for <see cref="{{ VectorXml }}" /> objects.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} operator *({{ VectorT }} left, {{ VectorT }} right)
    {
        {{ wrap vectorize 'left' 'right'; $"{a} * {b}"; end }}

        return new {{ VectorT }}(
            {{ wrap forEachDimension ','; $"left.{c} * right.{c}"; end }}
        );
    }

    /// <summary>Multiplies the specified vector by the specified scalar value.</summary>
    /// <param name="left">The vector.</param>
    /// <param name="right">The scalar value.</param>
    /// <returns>The scaled vector.</returns>
    /// <remarks>The <see cref="{{ VectorXml }}.op_Multiply" /> method defines the multiplication operation for <see cref="{{ VectorXml }}" /> objects.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} operator *({{ VectorT }} left, T right)
    {
        return left * new {{ VectorT }}(right);
    }

    /// <summary>Multiplies the scalar value by the specified vector.</summary>
    /// <param name="left">The vector.</param>
    /// <param name="right">The scalar value.</param>
    /// <returns>The scaled vector.</returns>
    /// <remarks>The <see cref="{{ VectorXml }}.op_Multiply" /> method defines the multiplication operation for <see cref="{{ VectorXml }}" /> objects.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} operator *(T left, {{ VectorT }} right)
    {
        return right * left;
    }

    /// <summary>Divides the first vector by the second.</summary>
    /// <param name="left">The first vector.</param>
    /// <param name="right">The second vector.</param>
    /// <returns>The vector that results from dividing <paramref name="left" /> by <paramref name="right" />.</returns>
    /// <remarks>The <see cref="{{ VectorXml }}.op_Division" /> method defines the division operation for <see cref="{{ VectorXml }}" /> objects.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} operator /({{ VectorT }} left, {{ VectorT }} right)
    {
        {{ wrap vectorize 'left' 'right'; $"{a} / {b}"; end }}

        return new {{ VectorT }}(
            {{ wrap forEachDimension ','; $"left.{c} / right.{c}"; end }}
        );
    }

    /// <summary>Divides the specified vector by a specified scalar value.</summary>
    /// <param name="value1">The vector.</param>
    /// <param name="value2">The scalar value.</param>
    /// <returns>The result of the division.</returns>
    /// <remarks>The <see cref="{{ VectorXml }}.op_Division" /> method defines the division operation for <see cref="{{ VectorXml }}" /> objects.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} operator /({{ VectorT }} value1, T value2)
    {
        return value1 / new {{ VectorT }}(value2);
    }

    /// <summary>Returns a value that indicates whether each pair of elements in two specified vectors is equal.</summary>
    /// <param name="left">The first vector to compare.</param>
    /// <param name="right">The second vector to compare.</param>
    /// <returns><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <see langword="false" />.</returns>
    /// <remarks>Two <see cref="{{ VectorXml }}" /> objects are equal if each element in <paramref name="left" /> is equal to the corresponding element in <paramref name="right" />.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator ==({{ VectorT }} left, {{ VectorT }} right)
    {
        return left.Equals(right);
    }

    /// <summary>Returns a value that indicates whether two specified vectors are not equal.</summary>
    /// <param name="left">The first vector to compare.</param>
    /// <param name="right">The second vector to compare.</param>
    /// <returns><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator !=({{ VectorT }} left, {{ VectorT }} right)
    {
        return !(left == right);
    }
    #endregion

    #region Equality
    /// <summary>Returns a value that indicates whether this instance and another vector are equal.</summary>
    /// <param name="other">The other vector.</param>
    /// <returns><see langword="true" /> if the two vectors are equal; otherwise, <see langword="false" />.</returns>
    /// <remarks>Two vectors are equal if their <see cref="X" />, <see cref="Y" />, <see cref="Z" />, and <see cref="W" /> elements are equal.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool Equals({{ VectorT }} other)
    {
        /*{{ wrap vectorize 'this' 'other'; $"{a}.Equals({b})"; end }}*/

        //return SpeedHelpers.FastEqualsUpTo4<{{ VectorT }}, T>(this, other);
        return
            {{ wrap forEachDimension ' &&'; $"{c}.Equals(other.{c})"; end }};
    }

    /// <summary>Returns a value that indicates whether this instance and a specified object are equal.</summary>
    /// <param name="obj">The object to compare with the current instance.</param>
    /// <returns><see langword="true" /> if the current instance and <paramref name="obj" /> are equal; otherwise, <see langword="false" />. If <paramref name="obj" /> is <see langword="null" />, the method returns <see langword="false" />.</returns>
    /// <remarks>The current instance and <paramref name="obj" /> are equal if <paramref name="obj" /> is a <see cref="{{ VectorXml }}" /> object and their corresponding elements are equal.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public override bool Equals([NotNullWhen(true)] object? obj)
    {
        return (obj is {{ VectorT }} other) && Equals(other);
    }

    {{~ if element_count <= max_numeric_dimensions ~}}
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool Equals(Vector{{ element_count }} other)
    {
        if (typeof(T) == typeof(float) && Vector128.IsHardwareAccelerated)
        {
            return Unsafe.BitCast<{{ VectorT }}, Vector{{ element_count }}>(this).AsVector128().Equals(other.AsVector128());
        }


        return
            {{ wrap forEachDimension ' &&'; $"float.CreateTruncating({c}).Equals(other.{c})"; end }};
    }
    {{~ end ~}}

    /// <summary>Returns the hash code for this instance.</summary>
    /// <returns>The hash code.</returns>
    public override int GetHashCode()
    {
        return HashCode.Combine({{ wrap forEachDimension ', ' newline:false; c; end }});
    }
    #endregion

    #region Format
    /// <summary>Returns the string representation of the current instance using default formatting.</summary>
    /// <returns>The string representation of the current instance.</returns>
    /// <remarks>This method returns a string in which each element of the vector is formatted using the "G" (general) format string and the formatting conventions of the current thread culture. The "&lt;" and "&gt;" characters are used to begin and end the string, and the current culture's <see cref="NumberFormatInfo.NumberGroupSeparator" /> property followed by a space is used to separate each element.</remarks>
    public override string ToString()
    {
        return ToString("G", null);
    }

    /// <summary>Returns the string representation of the current instance using the specified format string to format individual elements.</summary>
    /// <param name="format">A standard or custom numeric format string that defines the format of individual elements.</param>
    /// <returns>The string representation of the current instance.</returns>
    /// <remarks>This method returns a string in which each element of the vector is formatted using <paramref name="format" /> and the current culture's formatting conventions. The "&lt;" and "&gt;" characters are used to begin and end the string, and the current culture's <see cref="NumberFormatInfo.NumberGroupSeparator" /> property followed by a space is used to separate each element.</remarks>
    /// <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">Standard Numeric Format Strings</related>
    /// <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">Custom Numeric Format Strings</related>
    public string ToString([StringSyntax(StringSyntaxAttribute.NumericFormat)] string? format)
    {
        return ToString(format, null);
    }

    /// <summary>Returns the string representation of the current instance using the specified format string to format individual elements and the specified format provider to define culture-specific formatting.</summary>
    /// <param name="format">A standard or custom numeric format string that defines the format of individual elements.</param>
    /// <param name="formatProvider">A format provider that supplies culture-specific formatting information.</param>
    /// <returns>The string representation of the current instance.</returns>
    /// <remarks>This method returns a string in which each element of the vector is formatted using <paramref name="format" /> and <paramref name="formatProvider" />. The "&lt;" and "&gt;" characters are used to begin and end the string, and the format provider's <see cref="NumberFormatInfo.NumberGroupSeparator" /> property followed by a space is used to separate each element.</remarks>
    /// <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">Standard Numeric Format Strings</related>
    /// <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">Custom Numeric Format Strings</related>
    public string ToString([StringSyntax(StringSyntaxAttribute.NumericFormat)] string? format, IFormatProvider? formatProvider)
    {
        var separator = NumberFormatInfo.GetInstance(formatProvider).NumberGroupSeparator;

        Span<char> initialBuffer = stackalloc char[Math.Min((2 + (Count - 1) + (separator.Length * (Count - 1)) + (Count * 2)), 256)];

        // We can't use an interpolated string here because it won't allow us to pass `format`
        var handler = new DefaultInterpolatedStringHandler(
            4 + (separator.Length * 2),
            Count,
            formatProvider,
            initialBuffer
        );

        handler.AppendLiteral("<");
        {{~ for x in 0..<element_count ~}}
        handler.AppendFormatted({{ xyzw[x] }}, format);
            {{~ if !for.last ~}}
        handler.AppendLiteral(separator);
        handler.AppendLiteral(" ");
            {{~ end ~}}
        {{~ end ~}}
        handler.AppendLiteral(">");

        return handler.ToStringAndClear();
    }

    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        // Possible fast path for failure case:
        // if (destination.Length < 4) return false;

        var separator = NumberFormatInfo.GetInstance(provider).NumberGroupSeparator;

        // We can't use an interpolated string here because it won't allow us to pass `format`
        var handler = new MemoryExtensions.TryWriteInterpolatedStringHandler(
            4 + (separator.Length * 2),
            Count,
            destination,
            provider,
            out var shouldAppend
        );
        if (!shouldAppend)
        {
            charsWritten = 0;
            return false;
        }

        // Annoyingly we need to turn the span into a string for the string handler
        string? formatString = format.Length > 0 ? new string(format) : null;

        _ =
            handler.AppendLiteral("<") &&
            {{~ for x in 0..<element_count ~}}
            handler.AppendFormatted({{ xyzw[x] }}, formatString) &&
                {{~ if !for.last ~}}
            handler.AppendLiteral(separator) &&
            handler.AppendLiteral(" ") &&
                {{~ end ~}}
            {{~ end ~}}
            handler.AppendLiteral(">");

        return destination.TryWrite(ref handler, out charsWritten);
    }
    #endregion

    #region Casts
    public {{ Vector }}<TOther> As<TOther>() where TOther : INumberBase<TOther>
    {
        if (SpeedHelpers.TryFastConvert<{{ VectorT }}, T, {{ Vector }}<TOther>, TOther>(this, out var result))
        {
            return result;
        }

        return new {{ Vector }}<TOther>(
            {{ wrap forEachDimension ','; $"TOther.CreateTruncating({c})"; end }}
        );
    }

    private {{ Vector }}<TOther> AsChecked<TOther>() where TOther : INumberBase<TOther>
    {
        return new {{ Vector }}<TOther>(
            {{ wrap forEachDimension ','; $"TOther.CreateChecked({c})"; end }}
        );
    }
    public static explicit operator {{ Vector }}<byte>({{ VectorT }} self) => self.As<byte>();
    public static explicit operator {{ Vector }}<sbyte>({{ VectorT }} self) => self.As<sbyte>();
    public static explicit operator {{ Vector }}<short>({{ VectorT }} self) => self.As<short>();
    public static explicit operator {{ Vector }}<ushort>({{ VectorT }} self) => self.As<ushort>();
    public static explicit operator {{ Vector }}<int>({{ VectorT }} self) => self.As<int>();
    public static explicit operator {{ Vector }}<uint>({{ VectorT }} self) => self.As<uint>();
    public static explicit operator {{ Vector }}<long>({{ VectorT }} self) => self.As<long>();
    public static explicit operator {{ Vector }}<ulong>({{ VectorT }} self) => self.As<ulong>();
    public static explicit operator {{ Vector }}<Int128>({{ VectorT }} self) => self.As<Int128>();
    public static explicit operator {{ Vector }}<UInt128>({{ VectorT }} self) => self.As<UInt128>();
    public static explicit operator {{ Vector }}<Half>({{ VectorT }} self) => self.As<Half>();
    public static explicit operator {{ Vector }}<float>({{ VectorT }} self) => self.As<float>();
    public static explicit operator {{ Vector }}<double>({{ VectorT }} self) => self.As<double>();
    public static explicit operator {{ Vector }}<decimal>({{ VectorT }} self) => self.As<decimal>();
    public static explicit operator {{ Vector }}<Complex>({{ VectorT }} self) => self.As<Complex>();
    public static explicit operator {{ Vector }}<BigInteger>({{ VectorT }} self) => self.As<BigInteger>();

    public static explicit operator checked {{ Vector }}<byte>({{ VectorT }} self) => self.AsChecked<byte>();
    public static explicit operator checked {{ Vector }}<sbyte>({{ VectorT }} self) => self.AsChecked<sbyte>();
    public static explicit operator checked {{ Vector }}<short>({{ VectorT }} self) => self.AsChecked<short>();
    public static explicit operator checked {{ Vector }}<ushort>({{ VectorT }} self) => self.AsChecked<ushort>();
    public static explicit operator checked {{ Vector }}<int>({{ VectorT }} self) => self.AsChecked<int>();
    public static explicit operator checked {{ Vector }}<uint>({{ VectorT }} self) => self.AsChecked<uint>();
    public static explicit operator checked {{ Vector }}<long>({{ VectorT }} self) => self.AsChecked<long>();
    public static explicit operator checked {{ Vector }}<ulong>({{ VectorT }} self) => self.AsChecked<ulong>();
    public static explicit operator checked {{ Vector }}<Int128>({{ VectorT }} self) => self.AsChecked<Int128>();
    public static explicit operator checked {{ Vector }}<UInt128>({{ VectorT }} self) => self.AsChecked<UInt128>();
    public static explicit operator checked {{ Vector }}<Half>({{ VectorT }} self) => self.AsChecked<Half>();
    public static explicit operator checked {{ Vector }}<float>({{ VectorT }} self) => self.AsChecked<float>();
    public static explicit operator checked {{ Vector }}<double>({{ VectorT }} self) => self.AsChecked<double>();
    public static explicit operator checked {{ Vector }}<decimal>({{ VectorT }} self) => self.AsChecked<decimal>();
    public static explicit operator checked {{ Vector }}<Complex>({{ VectorT }} self) => self.AsChecked<Complex>();
    public static explicit operator checked {{ Vector }}<BigInteger>({{ VectorT }} self) => self.AsChecked<BigInteger>();

    // Cast to System.Numerics.Vector{{element_count}}
    {{~ if element_count <= max_numeric_dimensions ~}}
    public static explicit operator Vector{{ element_count }}({{ VectorT }} self) => new({{ wrap forEachDimension ', ' newline:false; $"float.CreateTruncating(self.{c})"; end }});
    public static explicit operator checked Vector{{ element_count }}({{ VectorT }} self) => new({{ wrap forEachDimension ', ' newline:false; $"float.CreateChecked(self.{c})"; end }});
    {{~ end ~}}

    // Downcast
    {{~ for dim in min_dimensions..<element_count ~}}
    public static explicit operator Vector{{dim}}D<T>({{ VectorT }} self) => new(
        {{- wrap forEachDimension ', ' newline:false dimensionLimit:dim; $"self.{c}"; end -}}
    );
    {{~ end ~}}

    // Upcast
    {{~ if element_count < max_dimensions ~}}
        {{~ for x in (element_count + 1)..max_dimensions ~}}
    public static explicit operator Vector{{x}}D<T>({{ VectorT }} self) => new(self, {{ wrap forEachDimension ', ' newline:false dimensionLimit:(x - element_count); $"T.Zero"; end }});
        {{~ end ~}}
    {{~ end ~}}

    // Upcast from System.Numerics.Vector < {{element_count}}
    {{~ for x in min_dimensions..<element_count ~}}
    public static explicit operator {{ VectorT }}(Vector{{x}} self) => new(
        {{-
            wrap forEachDimension ', ' newline:false dimensionLimit:x; $"T.CreateTruncating(self.{c})"; end
            ', '
            wrap forEachDimension ', ' newline:false dimensionLimit:(element_count - x); $"T.Zero"; end
        -}}
    );
    public static explicit operator checked {{ VectorT }}(Vector{{x}} self) => new(
        {{-
            wrap forEachDimension ', ' newline:false dimensionLimit:x; $"T.CreateChecked(self.{c})"; end
            ', '
            wrap forEachDimension ', ' newline:false dimensionLimit:(element_count - x); $"T.Zero"; end
        -}}
    );
    {{~ end ~}}

    // Downcast from System.Numerics.Vector >= {{element_count}}
    {{~ if element_count < max_numeric_dimensions ~}}
        {{~ for x in element_count..max_numeric_dimensions ~}}
    public static explicit operator {{ VectorT }}(Vector{{x}} self) => new({{ wrap forEachDimension ', ' newline:false; $"T.CreateTruncating(self.{c})"; end }});
    public static explicit operator checked {{ VectorT }}(Vector{{x}} self) => new({{ wrap forEachDimension ', ' newline:false; $"T.CreateChecked(self.{c})"; end }});
        {{~ end ~}}
    {{~ end ~}}

    public static implicit operator {{ VectorT }}((
        {{- wrap forEachDimension ', ' newline:false; $"T {c}"; end -}}
    ) components)
        => new({{- wrap forEachDimension ', ' newline:false; $"components.{c}"; end -}});

    #endregion

    public void Deconstruct({{ wrap forEachDimension ', ' newline:false; $"out T {cl}"; end }})
    {
        {{ wrap forEachDimension; $"{cl} = {c};"; end }}
    }
}

file interface IVec{{element_count}}
{
    // Returns null if incompatible. Throws OverflowException if overflowing
    {{VectorT}}? GetChecked<T>() where T : INumberBase<T>;
    {{VectorT}}? GetSaturating<T>() where T : INumberBase<T>;
    {{VectorT}}? GetTruncating<T>() where T : INumberBase<T>;
}

// {{ VectorT }}.INumber
public readonly partial struct {{VectorT}} :
    IDivisionOperators<{{VectorT}}, T, {{VectorT}}>,
    IMultiplyOperators<{{VectorT}}, T, {{VectorT}}>,
    INumberBase<{{VectorT}}>,
    IVec{{element_count}}
{
    /// <summary>Returns a vector whose elements are the absolute values of each of the specified vector's elements.</summary>
    /// <param name="value">A vector.</param>
    /// <returns>The absolute value vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static {{ VectorT }} INumberBase<{{ VectorT }}>.Abs({{ VectorT }} value) => {{ Vector }}.Abs(value);

    static {{VectorT}} IParsable<{{VectorT}}>.Parse(string s, IFormatProvider? provider)
        => Parse(s.AsSpan(), NumberStyles.None, provider);

    static {{VectorT}} ISpanParsable<{{VectorT}}>.Parse(ReadOnlySpan<char> s, IFormatProvider? provider)
        => Parse(s, NumberStyles.None, provider);

    public static {{VectorT}} Parse(string s, NumberStyles style = default, IFormatProvider? provider = null)
        => Parse(s.AsSpan(), style, provider);

    public static {{VectorT}} Parse(ReadOnlySpan<char> s, NumberStyles style = NumberStyles.None, IFormatProvider? provider = null)
        => TryParse(s, style, provider, out var result) ? result : throw new ArgumentException($"Failed to parse {nameof(Vector{{element_count}}D)}<{typeof(T)}>");

    public static bool TryParse(string? s, IFormatProvider? provider, out {{VectorT}} result)
        => TryParse(s.AsSpan(), NumberStyles.None, provider, out result);

    public static bool TryParse(string? s, NumberStyles style, IFormatProvider? provider, out {{VectorT}} result)
        => TryParse(s.AsSpan(), style, provider, out result);

    public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out {{VectorT}} result)
        => TryParse(s, NumberStyles.None, provider, out result);

    public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider, out {{VectorT}} result)
    {
        result = default;

        if (s[0] != '<') return false;
        if (s[^1] != '>') return false;

        var separator = NumberFormatInfo.GetInstance(provider).NumberGroupSeparator;

        s = s[1..^1];

        T? {{ xyzw | array.limit element_count | array.join ', ' | string.downcase }};

        {{~ for x in 0..<dimensionIndex ~}}
        {
            if (s.Length == 0) return false;

            var nextNumber = s.IndexOf(separator);
            if (nextNumber == -1)
            {
                return false;
            }

            if (!T.TryParse(s[..nextNumber], style, provider, out {{ xyzw[x] | string.downcase }})) return false;

            s = s[(nextNumber + separator.Length)..];
        }
        {{~ end ~}}

        {
            if (s.Length == 0) return false;

            if (!T.TryParse(s, style, provider, out {{ xyzw[dimensionIndex] | string.downcase }})) return false;
        }

        result = new {{VectorT}}({{ wrap forEachDimension ', ' newline:false; cl; end }});
        return true;
    }

    static bool INumberBase<{{VectorT}}>.IsCanonical({{VectorT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsCanonical(value.{c})"; end }};

    static bool INumberBase<{{VectorT}}>.IsComplexNumber({{VectorT}} value) => {{ wrap forEachDimension ' || ' newline:false; $"T.IsComplexNumber(value.{c})"; end }};

    static bool INumberBase<{{VectorT}}>.IsEvenInteger({{VectorT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsEvenInteger(value.{c})"; end }};

    static bool INumberBase<{{VectorT}}>.IsFinite({{VectorT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsFinite(value.{c})"; end }};

    static bool INumberBase<{{VectorT}}>.IsImaginaryNumber({{VectorT}} value) => {{ wrap forEachDimension ' || ' newline:false; $"T.IsImaginaryNumber(value.{c})"; end }};

    static bool INumberBase<{{VectorT}}>.IsInfinity({{VectorT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsInfinity(value.{c})"; end }};

    static bool INumberBase<{{VectorT}}>.IsInteger({{VectorT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsInteger(value.{c})"; end }};

    static bool INumberBase<{{VectorT}}>.IsNaN({{VectorT}} value) => {{ wrap forEachDimension ' || ' newline:false; $"T.IsNaN(value.{c})"; end }};

    static bool INumberBase<{{VectorT}}>.IsNegative({{VectorT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsNegative(value.{c})"; end }};

    static bool INumberBase<{{VectorT}}>.IsNegativeInfinity({{VectorT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsNegativeInfinity(value.{c})"; end }};

    static bool INumberBase<{{VectorT}}>.IsNormal({{VectorT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsNormal(value.{c})"; end }};

    static bool INumberBase<{{VectorT}}>.IsOddInteger({{VectorT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsOddInteger(value.{c})"; end }};

    static bool INumberBase<{{VectorT}}>.IsPositive({{VectorT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsPositive(value.{c})"; end }};

    static bool INumberBase<{{VectorT}}>.IsPositiveInfinity({{VectorT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsPositiveInfinity(value.{c})"; end }};

    static bool INumberBase<{{VectorT}}>.IsRealNumber({{VectorT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsRealNumber(value.{c})"; end }};

    static bool INumberBase<{{VectorT}}>.IsSubnormal({{VectorT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsSubnormal(value.{c})"; end }};

    static bool INumberBase<{{VectorT}}>.IsZero({{VectorT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsZero(value.{c})"; end }};

    static {{VectorT}} INumberBase<{{VectorT}}>.MaxMagnitude({{VectorT}} x, {{VectorT}} y) => new({{ wrap forEachDimension ', ' newline:false; $"T.MaxMagnitude(x.{c}, y.{c})"; end }});

    static {{VectorT}} INumberBase<{{VectorT}}>.MaxMagnitudeNumber({{VectorT}} x, {{VectorT}} y) => new({{ wrap forEachDimension ', ' newline:false; $"T.MaxMagnitudeNumber(x.{c}, y.{c})"; end }});

    static {{VectorT}} INumberBase<{{VectorT}}>.MinMagnitude({{VectorT}} x, {{VectorT}} y) => new({{ wrap forEachDimension ', ' newline:false; $"T.MinMagnitude(x.{c}, y.{c})"; end }});

    static {{VectorT}} INumberBase<{{VectorT}}>.MinMagnitudeNumber({{VectorT}} x, {{VectorT}} y) => new({{ wrap forEachDimension ', ' newline:false; $"T.MinMagnitudeNumber(x.{c}, y.{c})"; end }});

    static bool INumberBase<{{VectorT}}>.TryConvertFromChecked<TOther>(TOther value, out {{VectorT}} result)
    {
        if (value is {{VectorT}} v)
        {
            result = v;
            return true;
        }

        if (value is IVec{{element_count}} IVec{{element_count}} && IVec{{element_count}}.GetChecked<T>() is {} r)
        {
            result = r;
            return true;
        }

        result = default;
        return false;
    }

    static bool INumberBase<{{VectorT}}>.TryConvertFromSaturating<TOther>(TOther value, out {{VectorT}} result)
    {
        if (value is {{VectorT}} v)
        {
            result = v;
            return true;
        }

        if (value is IVec{{element_count}} IVec{{element_count}} && IVec{{element_count}}.GetSaturating<T>() is {} r)
        {
            result = r;
            return true;
        }

        result = default;
        return false;
    }

    static bool INumberBase<{{VectorT}}>.TryConvertFromTruncating<TOther>(TOther value, out {{VectorT}} result)
    {
        if (value is {{VectorT}} v)
        {
            result = v;
            return true;
        }

        if (value is IVec{{element_count}} IVec{{element_count}} && IVec{{element_count}}.GetTruncating<T>() is {} r)
        {
            result = r;
            return true;
        }

        result = default;
        return false;
    }

    static bool INumberBase<{{VectorT}}>.TryConvertToChecked<TOther>({{VectorT}} value, [MaybeNullWhen(false)] out TOther result)
        => TOther.TryConvertFromChecked(value, out result);

    static bool INumberBase<{{VectorT}}>.TryConvertToSaturating<TOther>({{VectorT}} value, [MaybeNullWhen(false)] out TOther result)
        => TOther.TryConvertFromSaturating(value, out result);

    static bool INumberBase<{{VectorT}}>.TryConvertToTruncating<TOther>({{VectorT}} value, [MaybeNullWhen(false)]out TOther result)
        => TOther.TryConvertFromTruncating(value, out result);

    {{Vector}}<T1>? IVec{{element_count}}.GetChecked<T1>() => T1.TryConvertFromChecked(X, out var x) ? new(x, {{ wrap forEachDimension ', ' newline:false dimensionOffset:1; $"T1.CreateChecked({c})"; end }}) : null;
    {{Vector}}<T1>? IVec{{element_count}}.GetSaturating<T1>() => T1.TryConvertFromSaturating(X, out var x) ? new(x, {{ wrap forEachDimension ', ' newline:false dimensionOffset:1; $"T1.CreateSaturating({c})"; end }}) : null;
    {{Vector}}<T1>? IVec{{element_count}}.GetTruncating<T1>() => T1.TryConvertFromTruncating(X, out var x) ? new(x, {{ wrap forEachDimension ', ' newline:false dimensionOffset:1; $"T1.CreateTruncating({c})"; end }}) : null;

    static ReadOnlySpan<T> IVector<{{VectorT}}, T>.AsSpan(in {{ VectorT }} vec) => vec.AsSpan();
}

// {{ VectorT }}.IReadOnlyList
public readonly partial struct {{ VectorT }} : IReadOnlyList<T>
{
    IEnumerator<T> IEnumerable<T>.GetEnumerator()
    {
        {{ wrap forEachDimension; $"yield return {c};"; end }}
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return ((IEnumerable<T>)this).GetEnumerator();
    }

    int IReadOnlyCollection<T>.Count => Count;
}

// {{ VectorT }}.IUtf8SpanParsableFormattable
public partial struct {{ VectorT }} :
    IUtf8SpanFormattable,
    IUtf8SpanParsable<{{ VectorT }}>
{
    public bool TryFormat(Span<byte> utf8Destination, out int bytesWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        // Possible fast path for failure case:
        // if (destination.Length < 4) return false;

        var separator = NumberFormatInfo.GetInstance(provider).NumberGroupSeparator;

        // We can't use an interpolated string here because it won't allow us to pass `format`
        var handler = new Utf8.TryWriteInterpolatedStringHandler(
            4 + (separator.Length * 2),
            Count,
            utf8Destination,
            provider,
            out var shouldAppend
        );
        if (!shouldAppend)
        {
            bytesWritten = 0;
            return false;
        }

        // Annoyingly we need to turn the span into a string for the string handler
        string? formatString = format.Length > 0 ? new string(format) : null;

        // JIT will automagically convert literals to utf8
        _ =
            handler.AppendLiteral("<") &&
            {{~ for x in 0..<element_count ~}}
            handler.AppendFormatted({{ xyzw[x] }}, formatString) &&
                {{~ if x < dimensionIndex ~}}
            handler.AppendLiteral(separator) &&
            handler.AppendLiteral(" ") &&
                {{~ end ~}}
            {{~ end ~}}
            handler.AppendLiteral(">");

        return Utf8.TryWrite(utf8Destination, ref handler, out bytesWritten);
    }

    public static {{ VectorT }} Parse(ReadOnlySpan<byte> utf8Text, IFormatProvider? provider)
        => TryParse(utf8Text, provider, out var result) ? result : throw new ArgumentException($"Failed to parse {nameof({{Vector}})}<{typeof(T)}>");

    public static bool TryParse(ReadOnlySpan<byte> s, IFormatProvider? provider, out {{ VectorT }} result)
    {
        result = default;

        if (s[0] != (byte)'<') return false;
        if (s[^1] != (byte)'>') return false;

        var separator = NumberGroupSeparatorTChar<byte>(NumberFormatInfo.GetInstance(provider));

        s = s[1..^1];

        T? {{ xyzw | array.limit element_count | array.join ', ' | string.downcase }};

        {{~ for x in 0..<(element_count - 1) ~}}
        {
            if (s.Length == 0) return false;

            var nextNumber = s.IndexOf(separator);
            if (nextNumber == -1)
            {
                return false;
            }

            if (!T.TryParse(s[..nextNumber], provider, out {{ xyzw[x] | string.downcase }})) return false;

            s = s[(nextNumber + separator.Length)..];
        }
        {{~ end ~}}

        {
            if (s.Length == 0) return false;

            if (!T.TryParse(s, provider, out {{ xyzw[element_count-1] | string.downcase }})) return false;
        }

        result = new {{VectorT}}({{ xyzw | array.limit element_count | array.join ', ' | string.downcase }});
        return true;

        [UnsafeAccessor(UnsafeAccessorKind.Method, Name = nameof(NumberGroupSeparatorTChar))]
        static extern ReadOnlySpan<TChar> NumberGroupSeparatorTChar<TChar>(NumberFormatInfo? c) where TChar : unmanaged;
    }

    static void IVector<{{VectorT}}, T>.CopyTo(in {{VectorT}} vector, T[] array) => vector.CopyTo(array);
    static void IVector<{{VectorT}}, T>.CopyTo(in {{VectorT}} vector, T[] array, int index) => vector.CopyTo(array, index);
    static void IVector<{{VectorT}}, T>.CopyTo(in {{VectorT}} vector, Span<T> destination) => vector.CopyTo(destination);
    static bool IVector<{{VectorT}}, T>.TryCopyTo(in {{VectorT}} vector, Span<T> destination) => vector.TryCopyTo(destination);
}

// {{ Vector }}
public static partial class {{ Vector }}
{
    #region CopyTo
    /// <summary>Copies the elements of the vector to a specified array.</summary>
    /// <param name="self">The vector to be copied.</param>
    /// <param name="array">The destination array.</param>
    /// <remarks><paramref name="array" /> must have at least {{ AmountName }} elements. The method copies the vector's elements starting at index 0.</remarks>
    /// <exception cref="NullReferenceException"><paramref name="array" /> is <see langword="null" />.</exception>
    /// <exception cref="ArgumentException">The number of elements in the current instance is greater than in the array.</exception>
    /// <exception cref="RankException"><paramref name="array" /> is multidimensional.</exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void CopyTo<T>(in this {{VectorT}} self, T[] array) where T : INumberBase<T>
    {
        // We explicitly don't check for `null` because historically this has thrown `NullReferenceException` for perf reasons

        ArgumentOutOfRangeException.ThrowIfLessThan(array.Length, {{VectorT}}.Count, nameof(array));

        Unsafe.WriteUnaligned(ref Unsafe.As<T, byte>(ref array[0]), self);
    }

    /// <summary>Copies the elements of the vector to a specified array starting at a specified index position.</summary>
    /// <param name="self">The vector to be copied.</param>
    /// <param name="array">The destination array.</param>
    /// <param name="index">The index at which to copy the first element of the vector.</param>
    /// <remarks><paramref name="array" /> must have a sufficient number of elements to accommodate the {{ AmountName }} vector elements. In other words, elements <paramref name="index" /> through <paramref name="index" /> + {{element_count}} must already exist in <paramref name="array" />.</remarks>
    /// <exception cref="NullReferenceException"><paramref name="array" /> is <see langword="null" />.</exception>
    /// <exception cref="ArgumentException">The number of elements in the current instance is greater than in the array.</exception>
    /// <exception cref="ArgumentOutOfRangeException"><paramref name="index" /> is less than zero.
    /// -or-
    /// <paramref name="index" /> is greater than or equal to the array length.</exception>
    /// <exception cref="RankException"><paramref name="array" /> is multidimensional.</exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void CopyTo<T>(in this {{VectorT}} self, T[] array, int index) where T : INumberBase<T>
    {
        // We explicitly don't check for `null` because historically this has thrown `NullReferenceException` for perf reasons

        ArgumentOutOfRangeException.ThrowIfGreaterThanOrEqual((uint)index, (uint)array.Length);
        ArgumentOutOfRangeException.ThrowIfLessThan((array.Length - index), {{VectorT}}.Count);

        Unsafe.WriteUnaligned(ref Unsafe.As<T, byte>(ref array[index]), self);
    }

    /// <summary>Copies the vector to the given <see cref="Span{T}" />. The length of the destination span must be at least {{element_count}}.</summary>
    /// <param name="self">The vector to be copied.</param>
    /// <param name="destination">The destination span which the values are copied into.</param>
    /// <exception cref="ArgumentException">If number of elements in source vector is greater than those available in destination span.</exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void CopyTo<T>(in this {{VectorT}} self, Span<T> destination) where T : INumberBase<T>
    {
        ArgumentOutOfRangeException.ThrowIfLessThan(destination.Length, {{VectorT}}.Count, nameof(destination));

        Unsafe.WriteUnaligned(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(destination)), self);
    }

    /// <summary>Attempts to copy the vector to the given <see cref="Span{Single}" />. The length of the destination span must be at least {{element_count}}.</summary>
    /// <param name="self">The vector to be copied.</param>
    /// <param name="destination">The destination span which the values are copied into.</param>
    /// <returns><see langword="true" /> if the source vector was successfully copied to <paramref name="destination" />. <see langword="false" /> if <paramref name="destination" /> is not large enough to hold the source vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool TryCopyTo<T>(in this {{VectorT}} self, Span<T> destination) where T : INumberBase<T>
    {
        if (destination.Length < {{VectorT}}.Count)
        {
            return false;
        }

        Unsafe.WriteUnaligned(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(destination)), self);
        return true;
    }
    #endregion

    #region Extension

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlySpan<T> AsSpan<T>(in this {{ VectorT }} vec) where T : INumberBase<T>
    {
        return MemoryMarshal.CreateReadOnlySpan<T>(ref Unsafe.As<{{ VectorT }}, T>(ref Unsafe.AsRef(in vec)), {{ VectorT }}.Count);
    }

    /// <summary>Returns the length of this vector object.</summary>
    /// <returns>The vector's length.</returns>
    /// <altmember cref="LengthSquared{T,TReturn}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TReturn Length<T, TReturn>(this {{ VectorT }} vec) where T : INumberBase<T> where TReturn : INumberBase<TReturn>, IRootFunctions<TReturn>
    {
        var lengthSquared = vec.LengthSquared<T, TReturn>();
        return TReturn.Sqrt(lengthSquared);
    }

    /// <summary>Returns the length of the vector squared.</summary>
    /// <returns>The vector's length squared.</returns>
    /// <remarks>This operation offers better performance than a call to the <see cref="Length{T,TReturn}" /> method.</remarks>
    /// <altmember cref="Length{T,TReturn}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TReturn LengthSquared<T, TReturn>(this {{ VectorT }} vec) where T : INumberBase<T> where TReturn : INumberBase<TReturn>
    {
        return Dot<T, TReturn>(vec, vec);
    }

    #endregion

    #region Basic

    /// <summary>Returns a new vector whose values are the product of each pair of elements in two specified vectors.</summary>
    /// <param name="left">The first vector.</param>
    /// <param name="right">The second vector.</param>
    /// <returns>The element-wise product vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} Multiply<T>({{ VectorT }} left, {{ VectorT }} right) where T : INumberBase<T>
    {
        return left * right;
    }

    /// <summary>Multiplies a vector by a specified scalar.</summary>
    /// <param name="left">The vector to multiply.</param>
    /// <param name="right">The scalar value.</param>
    /// <returns>The scaled vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} Multiply<T>({{ VectorT }} left, T right) where T : INumberBase<T>
    {
        return left * right;
    }

    /// <summary>Multiplies a scalar value by a specified vector.</summary>
    /// <param name="left">The scaled value.</param>
    /// <param name="right">The vector.</param>
    /// <returns>The scaled vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} Multiply<T>(T left, {{ VectorT }} right) where T : INumberBase<T>
    {
        return left * right;
    }

    /// <summary>Negates a specified vector.</summary>
    /// <param name="value">The vector to negate.</param>
    /// <returns>The negated vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} Negate<T>({{ VectorT }} value) where T : INumberBase<T>
    {
        return -value;
    }

    /// <summary>Subtracts the second vector from the first.</summary>
    /// <param name="left">The first vector.</param>
    /// <param name="right">The second vector.</param>
    /// <returns>The difference vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} Subtract<T>({{ VectorT }} left, {{ VectorT }} right) where T : INumberBase<T>
    {
        return left - right;
    }

    /// <summary>Adds two vectors together.</summary>
    /// <param name="left">The first vector to add.</param>
    /// <param name="right">The second vector to add.</param>
    /// <returns>The summed vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} Add<T>({{ VectorT }} left, {{ VectorT }} right) where T : INumberBase<T>
    {
        return left + right;
    }

    /// <summary>Divides the first vector by the second.</summary>
    /// <param name="left">The first vector.</param>
    /// <param name="right">The second vector.</param>
    /// <returns>The vector resulting from the division.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} Divide<T>({{ VectorT }} left, {{ VectorT }} right) where T : INumberBase<T>
    {
        return left / right;
    }

    /// <summary>Divides the specified vector by a specified scalar value.</summary>
    /// <param name="left">The vector.</param>
    /// <param name="divisor">The scalar value.</param>
    /// <returns>The vector that results from the division.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} Divide<T>({{ VectorT }} left, T divisor) where T : INumberBase<T>
    {
        return left / divisor;
    }

    #endregion

    #region Other

    /// <summary>Returns a vector whose elements are the absolute values of each of the specified vector's elements.</summary>
    /// <param name="value">A vector.</param>
    /// <returns>The absolute value vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} Abs<T>({{ VectorT }} value) where T : INumberBase<T>
    {
        {{ wrap vectorize 'value'; $"{vector}.Abs({a})"; end }}

        return new({{ wrap forEachDimension ', ' newline:false; $"T.Abs(value.{c})"; end }});
    }

    /// <summary>Restricts a vector between a minimum and a maximum value.</summary>
    /// <param name="value1">The vector to restrict.</param>
    /// <param name="min">The minimum value.</param>
    /// <param name="max">The maximum value.</param>
    /// <returns>The restricted vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} Clamp<T>({{ VectorT }} value1, {{ VectorT }} min, {{ VectorT }} max) where T : INumberBase<T>
    {
        {{ wrap vectorize 'value1' 'min' 'max'; $"{vector}.Min({vector}.Max({a}, {b}), {c})"; end }}

        // We must follow HLSL behavior in the case user specified min value is bigger than max value.
        return Min(Max(value1, min), max);
    }

    /// <summary>Computes the Euclidean distance between the two given points.</summary>
    /// <param name="value1">The first point.</param>
    /// <param name="value2">The second point.</param>
    /// <returns>The distance.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TReturn Distance<T, TReturn>({{ VectorT }} value1, {{ VectorT }} value2) where T : INumberBase<T> where TReturn : INumberBase<TReturn>, IRootFunctions<TReturn>
    {
        var distanceSquared = DistanceSquared<T, TReturn>(value1, value2);
        return TReturn.Sqrt(distanceSquared);
    }

    /// <summary>Returns the Euclidean distance squared between two specified points.</summary>
    /// <param name="value1">The first point.</param>
    /// <param name="value2">The second point.</param>
    /// <returns>The distance squared.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T DistanceSquared<T>({{ VectorT }} value1, {{ VectorT }} value2) where T : INumberBase<T>
    {
        var difference = value1 - value2;
        return Dot(difference, difference);
    }

    /// <summary>Returns the Euclidean distance squared between two specified points.</summary>
    /// <param name="value1">The first point.</param>
    /// <param name="value2">The second point.</param>
    /// <returns>The distance squared.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TReturn DistanceSquared<T, TReturn>({{ VectorT }} value1, {{ VectorT }} value2) where T : INumberBase<T> where TReturn : INumberBase<TReturn>
    {
        var difference = value1 - value2;
        return Dot<T, TReturn>(difference, difference);
    }

    /// <summary>Returns the dot product of two vectors.</summary>
    /// <param name="vector1">The first vector.</param>
    /// <param name="vector2">The second vector.</param>
    /// <returns>The dot product.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Dot<T>({{ VectorT }} vector1, {{ VectorT }} vector2) where T : INumberBase<T>
    {
        // TODO: vectorize return scalar
        return
            {{ wrap forEachDimension ' +'; $"vector1.{c} * vector2.{c}"; end -}};
    }

    /// <summary>Returns the dot product of two vectors.</summary>
    /// <param name="vector1">The first vector.</param>
    /// <param name="vector2">The second vector.</param>
    /// <returns>The dot product.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TReturn Dot<T, TReturn>({{ VectorT }} vector1, {{ VectorT }} vector2) where T : INumberBase<T> where TReturn : INumberBase<TReturn>
    {
        // TODO vectorize return converted (maybe not possible)
        return
            {{ wrap forEachDimension ' +'; $"TReturn.CreateTruncating(vector1.{c}) * TReturn.CreateTruncating(vector2.{c})"; end -}};
    }

    /// <summary>Performs a linear interpolation between two vectors based on the given weighting.</summary>
    /// <param name="value1">The first vector.</param>
    /// <param name="value2">The second vector.</param>
    /// <param name="amount">A value between 0 and 1 that indicates the weight of <paramref name="value2" />.</param>
    /// <returns>The interpolated vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ Vector }}<TFloat> Lerp<T, TFloat>({{ VectorT }} value1, {{ VectorT }} value2, TFloat amount) where T : INumberBase<T> where TFloat : INumberBase<TFloat>, IFloatingPoint<TFloat>
    {
        return (value1.As<TFloat>() * (TFloat.One - amount)) + (value2.As<TFloat>() * amount);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static {{ VectorT }} LerpUnchecked<T>({{ VectorT }} value1, {{ VectorT }} value2, T amount) where T : INumberBase<T>
    {
        return (value1.As<T>() * (T.One - amount)) + (value2.As<T>() * amount);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ Vector }}<TFloat> LerpClamped<T, TFloat>({{ VectorT }} value1, {{ VectorT }} value2, TFloat amount) where T : INumberBase<T> where TFloat : INumberBase<TFloat>, IFloatingPoint<TFloat>
    {
        amount = TFloat.Clamp(amount, TFloat.Zero, TFloat.One);
        return Lerp(value1, value2, amount);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static {{ VectorT }} LerpClampedUnchecked<T>({{ VectorT }} value1, {{ VectorT }} value2, T amount) where T : INumberBase<T>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static T ClampT(T value, T min, T max)
        {
            return T.MaxMagnitude(T.MaxMagnitude(value, min), max);
        }

        amount = ClampT(amount, T.Zero, T.One);
        return LerpUnchecked(value1, value2, amount);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ Vector }}<TFloat> Lerp<T, TFloat>({{ VectorT }} value1, {{ VectorT }} value2, {{Vector}}<TFloat> amount) where T : INumberBase<T> where TFloat : INumberBase<TFloat>, IFloatingPoint<TFloat>
    {
        return (value1.As<TFloat>() * ({{Vector}}<TFloat>.One - amount)) + (value2.As<TFloat>() * amount);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static {{ VectorT }} LerpUnchecked<T>({{ VectorT }} value1, {{ VectorT }} value2, {{ VectorT }} amount) where T : INumberBase<T>
    {
        return (value1.As<T>() * ({{VectorT}}.One - amount)) + (value2.As<T>() * amount);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ Vector }}<TFloat> LerpClamped<T, TFloat>({{ VectorT }} value1, {{ VectorT }} value2, {{Vector}}<TFloat> amount) where T : INumberBase<T> where TFloat : INumberBase<TFloat>, IFloatingPoint<TFloat>
    {
        amount = Clamp(amount, {{Vector}}<TFloat>.Zero, {{Vector}}<TFloat>.One);
        return Lerp(value1, value2, amount);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static {{ VectorT }} LerpClampedUnchecked<T>({{ VectorT }} value1, {{ VectorT }} value2, {{ VectorT }} amount) where T : INumberBase<T>
    {
        amount = Clamp(amount, {{ VectorT }}.Zero, {{ VectorT }}.One);
        return LerpUnchecked(value1, value2, amount);
    }

    /// <summary>Returns a vector whose elements are the maximum of each of the pairs of elements in two specified vectors.</summary>
    /// <param name="value1">The first vector.</param>
    /// <param name="value2">The second vector.</param>
    /// <returns>The maximized vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} Max<T>({{ VectorT }} value1, {{ VectorT }} value2) where T : INumberBase<T>
    {
        return new {{ VectorT }}(
            {{ wrap forEachDimension ', '; $"T.MaxMagnitudeNumber(value1.{c}, value2.{c})"; end }}
        );
    }

    /// <summary>Returns a vector whose elements are the minimum of each of the pairs of elements in two specified vectors.</summary>
    /// <param name="value1">The first vector.</param>
    /// <param name="value2">The second vector.</param>
    /// <returns>The minimized vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} Min<T>({{ VectorT }} value1, {{ VectorT }} value2) where T : INumberBase<T>
    {
        return new {{ VectorT }}(
        {{ wrap forEachDimension ', '; $"T.MinMagnitudeNumber(value1.{c}, value2.{c})"; end }}
        );
    }

    /// <summary>Returns a vector with the same direction as the specified vector, but with a length of one.</summary>
    /// <param name="value">The vector to normalize.</param>
    /// <returns>The normalized vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ Vector }}<TReturn> Normalize<T, TReturn>({{ VectorT }} value) where T : INumberBase<T> where TReturn : INumberBase<TReturn>, IRootFunctions<TReturn>
    {
        return value.As<TReturn>() / value.Length<T, TReturn>();
    }

    /// <summary>Returns a vector with the same direction as the specified vector, but with a length of one.</summary>
    /// <param name="value">The vector to normalize.</param>
    /// <returns>The normalized vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} Normalize<T>({{ VectorT }} value) where T : INumberBase<T>, IRootFunctions<T>
    {
        return value / value.Length();
    }

    /// <summary>Returns the reflection of a vector off a surface that has the specified normal.</summary>
    /// <param name="vector">The source vector.</param>
    /// <param name="normal">The normal of the surface being reflected off.</param>
    /// <returns>The reflected vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ Vector }}<TReturn> Reflect<T, TReturn>({{ VectorT }} vector, {{ VectorT }} normal) where T : INumberBase<T> where TReturn : INumberBase<TReturn>
    {
        var dot = Dot<T, TReturn>(vector, normal);
        return vector.As<TReturn>() - (Scalar<TReturn>.Two * (dot * normal.As<TReturn>()));
    }

    /// <summary>Returns a vector whose elements are the square root of each of a specified vector's elements.</summary>
    /// <param name="value">A vector.</param>
    /// <returns>The square root vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ Vector }}<TReturn> Sqrt<T, TReturn>({{ VectorT }} value) where T : INumberBase<T> where TReturn : INumberBase<TReturn>, IRootFunctions<TReturn>
    {
        return new {{ Vector }}<TReturn>(
            {{ wrap forEachDimension ', '; $"TReturn.Sqrt(TReturn.CreateTruncating(value.{c}))"; end }}
        );
    }

    // CANNOT BE DONE
    /*
    /// <summary>Transforms a vector by a specified 4x4 matrix.</summary>
    /// <param name="position">The vector to transform.</param>
    /// <param name="matrix">The transformation matrix.</param>
    /// <returns>The transformed vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} Transform<T>({{ VectorT }} position, Matrix4X4<T> matrix) where T : INumberBase<T>
    {
        return ({{ VectorT }})Vector4D.Transform(position, matrix);
    }

    /// <summary>Transforms a vector by the specified Quaternion rotation value.</summary>
    /// <param name="value">The vector to rotate.</param>
    /// <param name="rotation">The rotation to apply.</param>
    /// <returns>The transformed vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ Vector }}<TReturn> Transform<T, TQuat, TReturn>({{ VectorT }} value, Quaternion<TQuat> rotation) where T : INumberBase<T> where TReturn : INumberBase<TReturn> where TQuat : ITrigonometricFunctions<TQuat>, IRootFunctions<TQuat>
    {
        {{ wrap forEachDimension; $"var {cl2} = rotation.{c} + rotation.{c};"; end -}}
        var x2 = rotation.X + rotation.X;
        var y2 = rotation.Y + rotation.Y;
        var z2 = rotation.Z + rotation.Z;

        {{~

        func forEachDimensionSquared(sep = null, newline = true, endingNewline = false, dimensionLimit = null, dimensionOffset = null)
            dimensionLimit = (dimensionLimit ?? element_count) - 1
            dimensionOffset = dimensionOffset ?? 0
            for x in dimensionOffset..dimensionLimit
                for y in dimensionOffset..dimensionLimit
                    c = xyzw[x]
                    cl = c | string.downcase
                    d = xyzw[y]
                    dl = d | string.downcase
                    $$
                    if !for.last && sep != null
                        sep
                    end
                    if newline && (endingNewline || !for.last)
                        '\n'
                    end
                end
            end
        end

        ~}}

        {{ wrap forEachDimension; $"var {cl2} = rotation.{c} + rotation.{c};"; end -}}

        var wx2 = TReturn.CreateTruncating(rotation.W * x2);
        var wy2 = TReturn.CreateTruncating(rotation.W * y2);
        var wz2 = TReturn.CreateTruncating(rotation.W * z2);
        var xx2 = TReturn.CreateTruncating(rotation.X * x2);
        var xy2 = TReturn.CreateTruncating(rotation.X * y2);
        var xz2 = TReturn.CreateTruncating(rotation.X * z2);
        var yy2 = TReturn.CreateTruncating(rotation.Y * y2);
        var yz2 = TReturn.CreateTruncating(rotation.Y * z2);
        var zz2 = TReturn.CreateTruncating(rotation.Z * z2);

        return new {{ Vector }}<TReturn>(
            {{ wrap forEachDimension ', '; $"TReturn.Sqrt(TReturn.CreateTruncating(value.{c}))"; end }}
        );

        return new {{ Vector }}<TReturn>(
            TReturn.CreateTruncating(value.X) * (TReturn.One - yy2 - zz2) + TReturn.CreateTruncating(value.Y) * (xy2 - wz2) + TReturn.CreateTruncating(value.Z) * (xz2 + wy2),
            TReturn.CreateTruncating(value.X) * (xy2 + wz2) + TReturn.CreateTruncating(value.Y) * (TReturn.One - xx2 - zz2) + TReturn.CreateTruncating(value.Z) * (yz2 - wx2),
            TReturn.CreateTruncating(value.X) * (xz2 - wy2) + TReturn.CreateTruncating(value.Y) * (yz2 + wx2) + TReturn.CreateTruncating(value.Z) * (TReturn.One - xx2 - yy2)
        );
    }

    // /// <summary>Transforms a vector normal by the given 4x4 matrix.</summary>
    // /// <param name="normal">The source vector.</param>
    // /// <param name="matrix">The matrix.</param>
    // /// <returns>The transformed vector.</returns>
    // [MethodImpl(MethodImplOptions.AggressiveInlining)]
    // internal static {{ VectorT }} TransformNormal<T>({{ VectorT }} normal, in Matrix4x4 matrix) where T : INumberBase<T>
    // {
    //     var matrixX = new Vector4(matrix.M11, matrix.M12, matrix.M13, matrix.M14);
    //     var matrixY = new Vector4(matrix.M21, matrix.M22, matrix.M23, matrix.M24);
    //     var matrixZ = new Vector4(matrix.M31, matrix.M32, matrix.M33, matrix.M34);
    //     // var matrixW = new Vector4(matrix.M41, matrix.M42, matrix.M43, matrix.M44);
    //
    //     var result = matrixX * normal.X;
    //     result += matrixY * normal.Y;
    //     result += matrixZ * normal.Z;
    //     return result.AsVector128().AsVector3();
    // }
    */

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} Remainder<T>(this {{ VectorT }} left, {{ VectorT }} right) where T : INumberBase<T>, IModulusOperators<T, T, T>
    {
        return new {{ VectorT }}(
            {{ wrap forEachDimension ','; $"left.{c} % right.{c}"; end }}
        );
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} Remainder<T>(this {{ VectorT }} left, T right) where T : INumberBase<T>, IModulusOperators<T, T, T>
    {
        return new {{ VectorT }}(
            {{ wrap forEachDimension ','; $"left.{c} % right"; end }}
        );
    }
    #endregion

    #region Specializations

    /// <summary>Returns the length of this vector object.</summary>
    /// <returns>The vector's length.</returns>
    /// <altmember cref="LengthSquared{T}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Length<T>(this {{ VectorT }} vec) where T : INumberBase<T>, IRootFunctions<T>
    {
        return vec.Length<T, T>();
    }

    /// <summary>Returns the length of the vector squared.</summary>
    /// <returns>The vector's length squared.</returns>
    /// <remarks>This operation offers better performance than a call to the <see cref="Length{T}" /> method.</remarks>
    /// <altmember cref="Length{T}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T LengthSquared<T>(this {{ VectorT }} vec) where T : INumberBase<T>
    {
        return vec.LengthSquared<T, T>();
    }

    /// <summary>Performs a linear interpolation between two vectors based on the given weighting.</summary>
    /// <param name="value1">The first vector.</param>
    /// <param name="value2">The second vector.</param>
    /// <param name="amount">A value between 0 and 1 that indicates the weight of <paramref name="value2" />.</param>
    /// <returns>The interpolated vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} Lerp<T>({{ VectorT }} value1, {{ VectorT }} value2, T amount) where T : INumberBase<T>, IFloatingPoint<T>
    {
        return Lerp<T, T>(value1, value2, amount);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} LerpClamped<T>({{ VectorT }} value1, {{ VectorT }} value2, T amount) where T : INumberBase<T>, IFloatingPoint<T>
    {
        return LerpClamped<T, T>(value1, value2, amount);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} Lerp<T>({{ VectorT }} value1, {{ VectorT }} value2, {{ VectorT }} amount) where T : INumberBase<T>, IFloatingPoint<T>
    {
        return Lerp<T, T>(value1, value2, amount);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} LerpClamped<T>({{ VectorT }} value1, {{ VectorT }} value2, {{ VectorT }} amount) where T : INumberBase<T>, IFloatingPoint<T>
    {
        return LerpClamped<T, T>(value1, value2, amount);
    }

    /// <summary>Returns the reflection of a vector off a surface that has the specified normal.</summary>
    /// <param name="vector">The source vector.</param>
    /// <param name="normal">The normal of the surface being reflected off.</param>
    /// <returns>The reflected vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} Reflect<T>({{ VectorT }} vector, {{ VectorT }} normal) where T : IFloatingPoint<T>
    {
        return Reflect<T, T>(vector, normal);
    }

    /// <summary>Returns a vector whose elements are the square root of each of a specified vector's elements.</summary>
    /// <param name="value">A vector.</param>
    /// <returns>The square root vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} Sqrt<T>({{ VectorT }} value) where T : IFloatingPoint<T>, IRootFunctions<T>
    {
        return Sqrt<T, T>(value);
    }

    // CANNOT BE DONE
    /*
    /// <summary>Transforms a vector by the specified Quaternion rotation value.</summary>
    /// <param name="value">The vector to rotate.</param>
    /// <param name="rotation">The rotation to apply.</param>
    /// <returns>The transformed vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} Transform<T>({{ VectorT }} value, Quaternion<T> rotation)
        where T : IFloatingPoint<T>, ITrigonometricFunctions<T>, IRootFunctions<T>
    {
        return Transform<T, T, T>(value, rotation);
    }


    /// <summary>Transforms a vector by the specified Quaternion rotation value.</summary>
    /// <param name="value">The vector to rotate.</param>
    /// <param name="rotation">The rotation to apply.</param>
    /// <returns>The transformed vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ VectorT }} Transform<T, TQuat>({{ VectorT }} value, Quaternion<TQuat> rotation)
        where T : IFloatingPoint<T>
        where TQuat : ITrigonometricFunctions<TQuat>, IRootFunctions<TQuat>
    {
        return Transform<T, TQuat, T>(value, rotation);
    }
    */
    #endregion

    // Equivalent implementing IHyperbolicFunctions<System.Runtime.Intrinsics.Vector3>
    public static {{ VectorT }} Acosh<T>({{ VectorT }} x) where T : IHyperbolicFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Acosh(x.{c})"; end }});
    public static {{ VectorT }} Asinh<T>({{ VectorT }} x) where T : IHyperbolicFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Asinh(x.{c})"; end }});
    public static {{ VectorT }} Atanh<T>({{ VectorT }} x) where T : IHyperbolicFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Atanh(x.{c})"; end }});
    public static {{ VectorT }} Cosh<T>({{ VectorT }} x) where T : IHyperbolicFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Cosh(x.{c})"; end }});
    public static {{ VectorT }} Sinh<T>({{ VectorT }} x) where T : IHyperbolicFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Sinh(x.{c})"; end }});
    public static {{ VectorT }} Tanh<T>({{ VectorT }} x) where T : IHyperbolicFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Tanh(x.{c})"; end }});

    // Equivalent implementing ITrigonometricFunctions<System.Runtime.Intrinsics.Vector3>
    public static {{ VectorT }} Acos<T>({{ VectorT }} x) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Acos(x.{c})"; end }});
    public static {{ VectorT }} AcosPi<T>({{ VectorT }} x) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.AcosPi(x.{c})"; end }});
    public static {{ VectorT }} Asin<T>({{ VectorT }} x) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Asin(x.{c})"; end }});
    public static {{ VectorT }} AsinPi<T>({{ VectorT }} x) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.AsinPi(x.{c})"; end }});
    public static {{ VectorT }} Atan<T>({{ VectorT }} x) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Atan(x.{c})"; end }});
    public static {{ VectorT }} AtanPi<T>({{ VectorT }} x) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.AtanPi(x.{c})"; end }});
    public static {{ VectorT }} Cos<T>({{ VectorT }} x) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Cos(x.{c})"; end }});
    public static {{ VectorT }} CosPi<T>({{ VectorT }} x) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.CosPi(x.{c})"; end }});
    public static {{ VectorT }} DegreesToRadians<T>({{ VectorT }} degrees) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.DegreesToRadians(degrees.{c})"; end }});
    public static {{ VectorT }} RadiansToDegrees<T>({{ VectorT }} radians) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.RadiansToDegrees(radians.{c})"; end }});
    public static {{ VectorT }} Sin<T>({{ VectorT }} x) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Sin(x.{c})"; end }});
    public static {{ VectorT }} SinPi<T>({{ VectorT }} x) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.SinPi(x.{c})"; end }});
    public static {{ VectorT }} Tan<T>({{ VectorT }} x) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Tan(x.{c})"; end }});
    public static {{ VectorT }} TanPi<T>({{ VectorT }} x) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.TanPi(x.{c})"; end }});


    public static ({{ VectorT }} Sin, {{ VectorT }} Cos) SinCos<T>({{ VectorT }} x) where T : ITrigonometricFunctions<T>
    {
        {{ wrap forEachDimension; $"var (sin{c}, cos{c}) = T.SinCos(x.{c});"; end }}

        return (
            new {{ VectorT }}({{- wrap forEachDimension ', ' newline:false; $"sin{c}"; end -}}),
            new {{ VectorT }}({{- wrap forEachDimension ', ' newline:false; $"cos{c}"; end -}})
        );
    }

    public static ({{ VectorT }} SinPi, {{ VectorT }} CosPi) SinCosPi<T>({{ VectorT }} x) where T : ITrigonometricFunctions<T>
    {
        {{ wrap forEachDimension; $"var (sin{c}, cos{c}) = T.SinCosPi(x.{c});"; end }}

        return (
            new {{ VectorT }}({{- wrap forEachDimension ', ' newline:false; $"sin{c}"; end -}}),
            new {{ VectorT }}({{- wrap forEachDimension ', ' newline:false; $"cos{c}"; end -}})
        );
    }

    // Equivalent implementing ILogarithmicFunctions<System.Runtime.Intrinsics.Vector3>
    public static {{ VectorT }} Log<T>({{ VectorT }} x) where T : ILogarithmicFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Log(x.{c})"; end }});

    public static {{ VectorT }} Log<T>({{ VectorT }} x, {{ VectorT }} newBase) where T : ILogarithmicFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Log(x.{c}, newBase.{c})"; end }});
    public static {{ VectorT }} Log<T>({{ VectorT }} x, T newBase) where T : ILogarithmicFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Log(x.{c}, newBase)"; end }});
    public static {{ VectorT }} LogP1<T>({{ VectorT }} x) where T : ILogarithmicFunctions<T> => Log(x + {{ VectorT }}.One);
    public static {{ VectorT }} Log2<T>({{ VectorT }} x) where T : ILogarithmicFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Log2(x.{c})"; end }});
    public static {{ VectorT }} Log2P1<T>({{ VectorT }} x) where T : ILogarithmicFunctions<T> => Log2(x + {{ VectorT }}.One);
    public static {{ VectorT }} Log10<T>({{ VectorT }} x) where T : ILogarithmicFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Log10(x.{c})"; end }});
    public static {{ VectorT }} Log10P1<T>({{ VectorT }} x) where T : ILogarithmicFunctions<T> => Log10(x + {{ VectorT }}.One);

    // Equivalent implementing IExponentialFunctions<System.Runtime.Intrinsics.Vector3>
    public static {{ VectorT }} Exp<T>({{ VectorT }} x) where T : IExponentialFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Exp(x.{c})"; end }});
    public static {{ VectorT }} ExpM1<T>({{ VectorT }} x) where T : IExponentialFunctions<T> => Exp(x) - {{ VectorT }}.One;
    public static {{ VectorT }} Exp2<T>({{ VectorT }} x) where T : IExponentialFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Exp2(x.{c})"; end }});
    public static {{ VectorT }} Exp2M1<T>({{ VectorT }} x) where T : IExponentialFunctions<T> => Exp2(x) - {{ VectorT }}.One;
    public static {{ VectorT }} Exp10<T>({{ VectorT }} x) where T : IExponentialFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Exp10(x.{c})"; end }});
    public static {{ VectorT }} Exp10M1<T>({{ VectorT }} x) where T : IExponentialFunctions<T> => Exp10(x) - {{ VectorT }}.One;

    // Equivalent implementing IPowerFunctions<System.Runtime.Intrinsics.Vector3>
    public static {{ VectorT }} Pow<T>({{ VectorT }} x, {{ VectorT }} y) where T : IPowerFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Pow(x.{c}, y.{c})"; end }});
    public static {{ VectorT }} Pow<T>({{ VectorT }} x, T y) where T : IPowerFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Pow(x.{c}, y)"; end }});

    // Equivalent implementing IRootFunctions<System.Runtime.Intrinsics.Vector3>
    public static {{ VectorT }} Cbrt<T>({{ VectorT }} x) where T : IRootFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Cbrt(x.{c})"; end }});
    public static {{ VectorT }} Hypot<T>({{ VectorT }} x, {{ VectorT }} y) where T : IRootFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Hypot(x.{c}, y.{c})"; end }});
    public static {{ VectorT }} Hypot<T>({{ VectorT }} x, T y) where T : IRootFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Hypot(x.{c}, y)"; end }});
    public static {{ VectorT }} RootN<T>({{ VectorT }} x, int n) where T : IRootFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.RootN(x.{c}, n)"; end }});

    // IFloatingPoint<TSelf>
    public static {{ VectorT }} Round<T>({{ VectorT }} x) where T : IFloatingPoint<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Round(x.{c})"; end }});
    public static {{ VectorT }} Round<T>({{ VectorT }} x, int digits) where T : IFloatingPoint<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Round(x.{c}, digits)"; end }});
    public static {{ VectorT }} Round<T>({{ VectorT }} x, MidpointRounding mode) where T : IFloatingPoint<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Round(x.{c}, mode)"; end }});
    public static {{ VectorT }} Round<T>({{ VectorT }} x, int digits, MidpointRounding mode) where T : IFloatingPoint<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Round(x.{c}, digits, mode)"; end }});
    public static {{ VectorT }} Truncate<T>({{ VectorT }} x) where T : IFloatingPoint<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Truncate(x.{c})"; end }});

    // IFloatingPointIeee754<TSelf>
    public static {{ VectorT }} Atan2<T>({{ VectorT }} x, {{ VectorT }} y) where T : IFloatingPointIeee754<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Atan2(x.{c}, y.{c})"; end }});
    public static {{ VectorT }} Atan2Pi<T>({{ VectorT }} x, {{ VectorT }} y) where T : IFloatingPointIeee754<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Atan2Pi(x.{c}, y.{c})"; end }});
    public static {{ VectorT }} Atan2<T>({{ VectorT }} x, T y) where T : IFloatingPointIeee754<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Atan2(x.{c}, y)"; end }});
    public static {{ VectorT }} Atan2Pi<T>({{ VectorT }} x, T y) where T : IFloatingPointIeee754<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Atan2Pi(x.{c}, y)"; end }});
    public static {{ VectorT }} BitDecrement<T>({{ VectorT }} x) where T : IFloatingPointIeee754<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.BitDecrement(x.{c})"; end }});
    public static {{ VectorT }} BitIncrement<T>({{ VectorT }} x) where T : IFloatingPointIeee754<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.BitIncrement(x.{c})"; end }});

    public static {{ VectorT }} FusedMultiplyAdd<T>({{ VectorT }} left, {{ VectorT }} right, {{ VectorT }} addend) where T : IFloatingPointIeee754<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.FusedMultiplyAdd(left.{c}, right.{c}, addend.{c})"; end }});
    public static {{ VectorT }} ReciprocalEstimate<T>({{ VectorT }} x) where T : IFloatingPointIeee754<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.ReciprocalEstimate(x.{c})"; end }});
    public static {{ VectorT }} ReciprocalSqrtEstimate<T>({{ VectorT }} x) where T : IFloatingPointIeee754<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.ReciprocalSqrtEstimate(x.{c})"; end }});

    // INumber<T>
    // public static {{ VectorT }} Clamp<T>({{ VectorT }} value, {{ VectorT }} min, {{ VectorT }} max) where T : INumber<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Clamp(x.{c})"; end }});
    public static {{ VectorT }} CopySign<T>({{ VectorT }} value, {{ VectorT }} sign) where T : INumber<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.CopySign(value.{c}, sign.{c})"; end }});
    public static {{ VectorT }} CopySign<T>({{ VectorT }} value, T sign) where T : INumber<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.CopySign(value.{c}, sign)"; end }});
    public static {{ VectorT }} MaxNumber<T>({{ VectorT }} x, {{ VectorT }} y) where T : INumber<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.MaxNumber(x.{c}, y.{c})"; end }});
    public static {{ VectorT }} MinNumber<T>({{ VectorT }} x, {{ VectorT }} y) where T : INumber<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.MinNumber(x.{c}, y.{c})"; end }});

    // INumberBase<T>
    // public static {{ VectorT }} MaxMagnitude<T>({{ VectorT }} x, {{ VectorT }} y) where T : INumberBase<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.MaxMagnitude(x.{c}, y.{c})"; end }});
    // public static {{ VectorT }} MaxMagnitudeNumber<T>({{ VectorT }} x, {{ VectorT }} y) where T : INumberBase<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.MaxMagnitudeNumber(x.{c}, y.{c})"; end }});
    // public static {{ VectorT }} MinMagnitude<T>({{ VectorT }} x, {{ VectorT }} y) where T : INumberBase<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.MinMagnitude(x.{c}, y.{c})"; end }});
    // public static {{ VectorT }} MinMagnitudeNumber<T>({{ VectorT }} x, {{ VectorT }} y) where T : INumberBase<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.MinMagnitudeNumber(x.{c}, y.{c})"; end }});
    // (there's no reason you would want these.)



    // IFloatingPointIeee754<TSelf>
    public static {{ Vector }}<int> ILogB<T>({{ VectorT }} x) where T : IFloatingPointIeee754<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.ILogB(x.{c})"; end }});
    public static {{ VectorT }} ScaleB<T>({{ VectorT }} x, {{ Vector }}<int> n) where T : IFloatingPointIeee754<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.ScaleB(x.{c}, n.{c})"; end }});
    public static {{ VectorT }} ScaleB<T>({{ VectorT }} x, int n) where T : IFloatingPointIeee754<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.ScaleB(x.{c}, n)"; end }});

    public static {{ Vector }}<int> RoundToInt<T>({{ VectorT }} vector) where T : IFloatingPoint<T>
    {
        return new {{ Vector }}<int>(
            {{ wrap forEachDimension ','; $"int.CreateSaturating(T.Round(vector.{c}))"; end }}
        );
    }

    public static {{ Vector }}<int> FloorToInt<T>({{ VectorT }} vector) where T : IFloatingPoint<T>
    {
        return new {{ Vector }}<int>(
            {{ wrap forEachDimension ','; $"int.CreateSaturating(T.Floor(vector.{c}))"; end }}
        );
    }

    public static {{ Vector }}<int> CeilingToInt<T>({{ VectorT }} vector) where T : IFloatingPoint<T>
    {
        return new {{ Vector }}<int>(
            {{ wrap forEachDimension ','; $"int.CreateSaturating(T.Ceiling(vector.{c}))"; end }}
        );
    }

    public static {{ Vector }}<TInt> RoundToInt<T, TInt>({{ VectorT }} vector) where T : IFloatingPoint<T> where TInt : IBinaryInteger<TInt>
    {
        return new {{ Vector }}<TInt>(
            {{ wrap forEachDimension ','; $"TInt.CreateSaturating(T.Round(vector.{c}))"; end }}
        );
    }

    public static {{ Vector }}<TInt> FloorToInt<T, TInt>({{ VectorT }} vector) where T : IFloatingPoint<T> where TInt : IBinaryInteger<TInt>
    {
        return new {{ Vector }}<TInt>(
            {{ wrap forEachDimension ','; $"TInt.CreateSaturating(T.Floor(vector.{c}))"; end }}
        );
    }

    public static {{ Vector }}<TInt> CeilingToInt<T, TInt>({{ VectorT }} vector) where T : IFloatingPoint<T> where TInt : IBinaryInteger<TInt>
    {
        return new {{ Vector }}<TInt>(
            {{ wrap forEachDimension ','; $"TInt.CreateSaturating(T.Ceiling(vector.{c}))"; end }}
        );
    }

    {{~ if element_count <= max_numeric_dimensions ~}}
    public static {{ Vector }}<float> AsGeneric(this Vector{{element_count}} vector)
        => Unsafe.BitCast<Vector{{element_count}}, {{ Vector }}<float>>(vector);

    public static Vector{{element_count}} AsNumerics(this {{ Vector }}<float> vector)
        => Unsafe.BitCast<{{ Vector }}<float>, Vector{{element_count}}>(vector);
    {{~ end ~}}
}

// IVector<{{VectorT}}, T>
public readonly partial struct {{VectorT}}
{
    T IVector<{{VectorT}}, T>.LengthSquared()
        => this.LengthSquared();
    static {{VectorT}} IVector<{{VectorT}}, T>.Multiply({{VectorT}} left, {{VectorT}} right)
        => {{Vector}}.Multiply(left, right);
    static {{VectorT}} IVector<{{VectorT}}, T>.Multiply({{VectorT}} left, T right)
        => {{Vector}}.Multiply(left, right);
    static {{VectorT}} IVector<{{VectorT}}, T>.Multiply(T left, {{VectorT}} right)
        => {{Vector}}.Multiply(left, right);
    static {{VectorT}} IVector<{{VectorT}}, T>.Negate({{VectorT}} value)
        => {{Vector}}.Negate(value);
    static {{VectorT}} IVector<{{VectorT}}, T>.Subtract({{VectorT}} left, {{VectorT}} right)
        => {{Vector}}.Subtract(left, right);
    static {{VectorT}} IVector<{{VectorT}}, T>.Add({{VectorT}} left, {{VectorT}} right)
        => {{Vector}}.Add(left, right);
    static {{VectorT}} IVector<{{VectorT}}, T>.Divide({{VectorT}} left, {{VectorT}} right)
        => {{Vector}}.Divide(left, right);
    static {{VectorT}} IVector<{{VectorT}}, T>.Divide({{VectorT}} left, T divisor)
        => {{Vector}}.Divide(left, divisor);
    static {{VectorT}} IVector<{{VectorT}}, T>.Clamp({{VectorT}} value1, {{VectorT}} min, {{VectorT}} max)
        => {{Vector}}.Clamp(value1, min, max);
    static TReturn IVector<{{VectorT}}, T>.Distance<TReturn>({{VectorT}} value1, {{VectorT}} value2)
        => {{Vector}}.Distance<T, TReturn>(value1, value2);
    static T IVector<{{VectorT}}, T>.DistanceSquared({{VectorT}} value1, {{VectorT}} value2)
        => {{Vector}}.DistanceSquared(value1, value2);
    static TReturn IVector<{{VectorT}}, T>.DistanceSquared<TReturn>({{VectorT}} value1, {{VectorT}} value2)
        => {{Vector}}.DistanceSquared<T, TReturn>(value1, value2);
    static T IVector<{{VectorT}}, T>.Dot({{VectorT}} vector1, {{VectorT}} vector2)
        => {{Vector}}.Dot(vector1, vector2);
    static TReturn IVector<{{VectorT}}, T>.Dot<TReturn>({{VectorT}} vector1, {{VectorT}} vector2)
        => {{Vector}}.Dot<T, TReturn>(vector1, vector2);
    static {{VectorT}} IVector<{{VectorT}}, T>.Max({{VectorT}} value1, {{VectorT}} value2)
        => {{Vector}}.Max(value1, value2);
    static {{VectorT}} IVector<{{VectorT}}, T>.Min({{VectorT}} value1, {{VectorT}} value2)
        => {{Vector}}.Min(value1, value2);

    static {{VectorT}} IVector<{{VectorT}}, T>.Lerp({{VectorT}} value1, {{VectorT}} value2, T amount) /* where T : IFloatingPoint<T> */
    {
        Helpers.CheckTypeAndThrow<{{VectorT}}, T>(typeof(IFloatingPoint<>));
        return {{Vector}}.LerpUnchecked(value1, value2, amount);
    }

    static {{VectorT}} IVector<{{VectorT}}, T>.LerpClamped({{VectorT}} value1, {{VectorT}} value2, T amount) /* where T : IFloatingPoint<T> */
    {
        Helpers.CheckTypeAndThrow<{{VectorT}}, T>(typeof(IFloatingPoint<>));
        return {{Vector}}.LerpClampedUnchecked(value1, value2, amount);
    }

    static {{VectorT}} IVector<{{VectorT}}, T>.Lerp({{VectorT}} value1, {{VectorT}} value2, {{VectorT}} amount) /* where T : IFloatingPoint<T> */
    {
        Helpers.CheckTypeAndThrow<{{VectorT}}, T>(typeof(IFloatingPoint<>));
        return {{Vector}}.LerpUnchecked(value1, value2, amount);
    }

    static {{VectorT}} IVector<{{VectorT}}, T>.LerpClamped({{VectorT}} value1, {{VectorT}} value2, {{VectorT}} amount) /* where T : IFloatingPoint<T> */
    {
        Helpers.CheckTypeAndThrow<{{VectorT}}, T>(typeof(IFloatingPoint<>));
        return {{Vector}}.LerpClampedUnchecked(value1, value2, amount);
    }

    static {{VectorT}} IVector<{{VectorT}}, T>.Reflect({{VectorT}} vector, {{VectorT}} normal) /* where T : IFloatingPoint<T> */
    {
        Helpers.CheckTypeAndThrow<{{VectorT}}, T>(typeof(IFloatingPoint<>));
        return {{Vector}}.Reflect<T, T>(vector, normal);
    }
}