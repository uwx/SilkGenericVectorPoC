using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Numerics;
using System.Runtime.CompilerServices;

namespace GenericVector.Experimental;

/// <summary>
/// This class abuses member visibility semantics in C# in order to access the TryConvertFrom and TryConvertTo members
/// of <see cref="INumberBase{TSelf}"/> without having to implement that interface. It should not be instantiated or
/// used directly except for <see cref="TryConvertChecked{TIn,TOut}"/>, <see cref="TryConvertSaturating{TIn,TOut}"/>
/// and <see cref="TryConvertTruncating{TIn,TOut}"/>.
/// </summary>
internal class ShamelessExploit : INumberBase<ShamelessExploit>
{
    #region ShamelessExploit
    private ShamelessExploit() => throw new InvalidOperationException();
    public override bool Equals(object? obj) => throw new InvalidOperationException();
    public override int GetHashCode() => throw new InvalidOperationException();
    bool IEquatable<ShamelessExploit>.Equals(ShamelessExploit? other) => throw new InvalidOperationException();
    string IFormattable.ToString(string? format, IFormatProvider? formatProvider) => throw new InvalidOperationException();
    bool ISpanFormattable.TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider) => throw new InvalidOperationException();
    static ShamelessExploit IParsable<ShamelessExploit>.Parse(string s, IFormatProvider? provider) => throw new InvalidOperationException();
    static bool IParsable<ShamelessExploit>.TryParse(string? s, IFormatProvider? provider, out ShamelessExploit result) => throw new InvalidOperationException();
    static ShamelessExploit ISpanParsable<ShamelessExploit>.Parse(ReadOnlySpan<char> s, IFormatProvider? provider) => throw new InvalidOperationException();
    static bool ISpanParsable<ShamelessExploit>.TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out ShamelessExploit result) => throw new InvalidOperationException();
    static ShamelessExploit IAdditionOperators<ShamelessExploit, ShamelessExploit, ShamelessExploit>.operator +(ShamelessExploit left, ShamelessExploit right) => throw new InvalidOperationException();
    static ShamelessExploit IAdditiveIdentity<ShamelessExploit, ShamelessExploit>.AdditiveIdentity => throw new InvalidOperationException();
    static ShamelessExploit IDivisionOperators<ShamelessExploit, ShamelessExploit, ShamelessExploit>.operator /(ShamelessExploit left, ShamelessExploit right) => throw new InvalidOperationException();
    static bool IEqualityOperators<ShamelessExploit, ShamelessExploit, bool>.operator ==(ShamelessExploit? left, ShamelessExploit? right) => throw new InvalidOperationException();
    static bool IEqualityOperators<ShamelessExploit, ShamelessExploit, bool>.operator !=(ShamelessExploit? left, ShamelessExploit? right) => throw new InvalidOperationException();
    static ShamelessExploit IIncrementOperators<ShamelessExploit>.operator ++(ShamelessExploit value) => throw new InvalidOperationException();
    static ShamelessExploit IMultiplicativeIdentity<ShamelessExploit, ShamelessExploit>.MultiplicativeIdentity => throw new InvalidOperationException();
    static ShamelessExploit ISubtractionOperators<ShamelessExploit, ShamelessExploit, ShamelessExploit>.operator -(ShamelessExploit left, ShamelessExploit right) => throw new InvalidOperationException();
    static ShamelessExploit IUnaryNegationOperators<ShamelessExploit, ShamelessExploit>.operator -(ShamelessExploit value) => throw new InvalidOperationException();
    static ShamelessExploit IUnaryPlusOperators<ShamelessExploit, ShamelessExploit>.operator +(ShamelessExploit value) => throw new InvalidOperationException();
    static ShamelessExploit INumberBase<ShamelessExploit>.Abs(ShamelessExploit value) => throw new InvalidOperationException();
    static bool INumberBase<ShamelessExploit>.IsCanonical(ShamelessExploit value) => throw new InvalidOperationException();
    static bool INumberBase<ShamelessExploit>.IsComplexNumber(ShamelessExploit value) => throw new InvalidOperationException();
    static bool INumberBase<ShamelessExploit>.IsEvenInteger(ShamelessExploit value) => throw new InvalidOperationException();
    static bool INumberBase<ShamelessExploit>.IsFinite(ShamelessExploit value) => throw new InvalidOperationException();
    static bool INumberBase<ShamelessExploit>.IsImaginaryNumber(ShamelessExploit value) => throw new InvalidOperationException();
    static bool INumberBase<ShamelessExploit>.IsInfinity(ShamelessExploit value) => throw new InvalidOperationException();
    static bool INumberBase<ShamelessExploit>.IsInteger(ShamelessExploit value) => throw new InvalidOperationException();
    static bool INumberBase<ShamelessExploit>.IsNaN(ShamelessExploit value) => throw new InvalidOperationException();
    static bool INumberBase<ShamelessExploit>.IsNegative(ShamelessExploit value) => throw new InvalidOperationException();
    static bool INumberBase<ShamelessExploit>.IsNegativeInfinity(ShamelessExploit value) => throw new InvalidOperationException();
    static bool INumberBase<ShamelessExploit>.IsNormal(ShamelessExploit value) => throw new InvalidOperationException();
    static bool INumberBase<ShamelessExploit>.IsOddInteger(ShamelessExploit value) => throw new InvalidOperationException();
    static bool INumberBase<ShamelessExploit>.IsPositive(ShamelessExploit value) => throw new InvalidOperationException();
    static bool INumberBase<ShamelessExploit>.IsPositiveInfinity(ShamelessExploit value) => throw new InvalidOperationException();
    static bool INumberBase<ShamelessExploit>.IsRealNumber(ShamelessExploit value) => throw new InvalidOperationException();
    static bool INumberBase<ShamelessExploit>.IsSubnormal(ShamelessExploit value) => throw new InvalidOperationException();
    static bool INumberBase<ShamelessExploit>.IsZero(ShamelessExploit value) => throw new InvalidOperationException();
    static ShamelessExploit INumberBase<ShamelessExploit>.MaxMagnitude(ShamelessExploit x, ShamelessExploit y) => throw new InvalidOperationException();
    static ShamelessExploit INumberBase<ShamelessExploit>.MaxMagnitudeNumber(ShamelessExploit x, ShamelessExploit y) => throw new InvalidOperationException();
    static ShamelessExploit INumberBase<ShamelessExploit>.MinMagnitude(ShamelessExploit x, ShamelessExploit y) => throw new InvalidOperationException();
    static ShamelessExploit INumberBase<ShamelessExploit>.MinMagnitudeNumber(ShamelessExploit x, ShamelessExploit y) => throw new InvalidOperationException();
    static ShamelessExploit INumberBase<ShamelessExploit>.Parse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider) => throw new InvalidOperationException();
    static ShamelessExploit INumberBase<ShamelessExploit>.Parse(string s, NumberStyles style, IFormatProvider? provider) => throw new InvalidOperationException();
    static bool INumberBase<ShamelessExploit>.TryConvertFromChecked<TOther>(TOther value, out ShamelessExploit result) => throw new InvalidOperationException();
    static bool INumberBase<ShamelessExploit>.TryConvertFromSaturating<TOther>(TOther value, out ShamelessExploit result) => throw new InvalidOperationException();
    static bool INumberBase<ShamelessExploit>.TryConvertFromTruncating<TOther>(TOther value, out ShamelessExploit result) => throw new InvalidOperationException();
    static bool INumberBase<ShamelessExploit>.TryConvertToChecked<TOther>(ShamelessExploit value, out TOther result) => throw new InvalidOperationException();
    static bool INumberBase<ShamelessExploit>.TryConvertToSaturating<TOther>(ShamelessExploit value, out TOther result) => throw new InvalidOperationException();
    static bool INumberBase<ShamelessExploit>.TryConvertToTruncating<TOther>(ShamelessExploit value, out TOther result) => throw new InvalidOperationException();
    static bool INumberBase<ShamelessExploit>.TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider, out ShamelessExploit result) => throw new InvalidOperationException();
    static bool INumberBase<ShamelessExploit>.TryParse(string? s, NumberStyles style, IFormatProvider? provider, out ShamelessExploit result) => throw new InvalidOperationException();
    static ShamelessExploit INumberBase<ShamelessExploit>.One => throw new InvalidOperationException();
    static int INumberBase<ShamelessExploit>.Radix => throw new InvalidOperationException();
    static ShamelessExploit INumberBase<ShamelessExploit>.Zero => throw new InvalidOperationException();
    static ShamelessExploit IDecrementOperators<ShamelessExploit>.operator --(ShamelessExploit value) => throw new InvalidOperationException();
    static ShamelessExploit IMultiplyOperators<ShamelessExploit, ShamelessExploit, ShamelessExploit>.operator *(ShamelessExploit left, ShamelessExploit right) => throw new InvalidOperationException();
    #endregion

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool TryConvertChecked<TIn, TOut>(TIn @in, [MaybeNullWhen(false)] out TOut result)
        where TIn : INumberBase<TIn>
        where TOut : INumberBase<TOut>
    {
        return TOut.TryConvertFromChecked(@in, out result) || TIn.TryConvertToChecked(@in, out result);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool TryConvertSaturating<TIn, TOut>(TIn @in, [MaybeNullWhen(false)] out TOut result)
        where TIn : INumberBase<TIn>
        where TOut : INumberBase<TOut>
    {
        return TOut.TryConvertFromSaturating(@in, out result) || TIn.TryConvertToSaturating(@in, out result);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool TryConvertTruncating<TIn, TOut>(TIn @in, [MaybeNullWhen(false)] out TOut result)
        where TIn : INumberBase<TIn>
        where TOut : INumberBase<TOut>
    {
        return TOut.TryConvertFromTruncating(@in, out result) || TIn.TryConvertToTruncating(@in, out result);
    }
}