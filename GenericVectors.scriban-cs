using System.Collections;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;
using System.Runtime.Serialization;
using System.Text.Unicode;

namespace GenericVector;

{{~ for vecN in min_dimensions..max_dimensions
    #for vecN in 3..3
-}}
{{~
    dimensionIndex = vecN - 1

    TypeName = $"Vector{vecN}D"
    TypeNameT = TypeName + '<T>'
    DocName = TypeName + '{T}'

    xyzw = ["X", "Y", "Z", "W"]
    ComponentsLower = xyzw | array.each @string.downcase
    Parameters = ["T x", "T y", "T z", "T w"]
    # ValueValue = [ "value.X", "value.Y", "value.Z", "value.W"]
    AmountName = "fuck"
    case vecN
        when 1
            AmountName = "one"
        when 2
            AmountName = "two"
        when 3
            AmountName = "three"
        when 4
            AmountName = "four"
    end

    max(x, y) = x > y ? x : y
    min(x, y) = x < y ? x : y

    func slice(value, indexStart = 0, indexEnd = null)
        len = object.size value

        indexEnd = indexEnd ?? len

        # If indexStart >= str.length, an empty string is returned.
        # If indexStart < 0, the index is counted from the end of the string. More formally, in this case, the substring starts at max(indexStart + str.length, 0).
        # If indexStart is omitted, undefined, or cannot be converted to a number, it's treated as 0.
        # If indexEnd is omitted, undefined, or cannot be converted to a number, or if indexEnd >= str.length, slice() extracts to the end of the string.
        # If indexEnd < 0, the index is counted from the end of the string. More formally, in this case, the substring ends at max(indexEnd + str.length, 0).
        # If indexEnd <= indexStart after normalizing negative values (i.e. indexEnd represents a character that's before indexStart), an empty string is returned.

        if indexStart < 0
            indexStart = max (indexStart + len) 0
        end

        if indexEnd < 0
            indexEnd = max (indexEnd + len) 0
        end

        case object.typeof value
            when 'string'
                if indexStart >= len || indexEnd <= indexStart
                    ret ''
                end

                ret value | string.slice indexStart (indexEnd - indexStart)
            when 'boolean'
                ret value
            when 'number'
                ret value
            when 'array'
                if indexStart >= len || indexEnd <= indexStart
                    ret []
                end

                ret value | array.limit indexEnd | array.offset indexStart
            when 'iterator'
                ret value
            when 'object'
                ret value
            else
                ret value
        end
    end

    func valueValue(prefix, downcase = false)
        arr = []
        for x in 0..<max_dimensions
            arr = arr | array.add (prefix + (downcase ? (xyzw[x] | string.downcase) : xyzw[x]))
        end
        ret arr
    end

    func humanizeAnd(items)
        if items.size == 1
            ret items[0]
        end

        itemsRest = items | array.limit (items.size - 1)
        itemLast = items[items.size - 1]
        ret $"{itemsRest | array.join ', '} and {itemLast}"
    end

    func operation(x, left, op, right, connector)
        s = $"({left}.{xyzw[x]} {op} {right}.{xyzw[x]})"
        if x < vecN - 1
            s += connector
        end
        ret s
    end

    func complexOperation(x, left1, left2, op, right1, right2, connector)
        s = $"({left1}{xyzw[x]}{left2} {op} {right1}{xyzw[x]}{right2})"
        if x < vecN - 1
            s += connector
        end
        ret s
    end

    func repeatCall(method, parameter, x = null, sep = ', ', startOffset = 0)
        list = []
        for x in startOffset..<(x ?? vecN)
            list = list | array.add $"{method}({parameter}.{xyzw[x]})"
        end
        ret list | array.join sep
    end

    func repeatCall2(method, parameter, parameter2, x = null, sep = ', ', startOffset = 0)
        list = []
        for x in 0..<(x ?? vecN)
            list = list | array.add $"{method}({parameter}.{xyzw[x]}, {parameter2}.{xyzw[x]})"
        end
        ret list | array.join sep
    end

    func forEachDimension(sep = null, newline = true, endingNewline = false, dimensionLimit = null, dimensionOffset = null)
        dimensionLimit = (dimensionLimit ?? vecN) - 1
        dimensionOffset = dimensionOffset ?? 0
        for x in dimensionOffset..dimensionLimit
            c = xyzw[x]
            cl = c | string.downcase
            $$
            if !for.last && sep != null
                sep
            end
            if newline && (endingNewline || !for.last)
                '\n'
            end
        end
    end
~}}

// {{ TypeNameT }}
[StructLayout(LayoutKind.Sequential), DataContract, Serializable]
public readonly partial struct {{TypeNameT}} : IVector<{{TypeNameT}}, T>, IVectorAlso<{{TypeNameT}}, T>, IEquatable<Vector{{vecN}}>, ISpanFormattable
    where T : INumberBase<T>
{
    {{~ for x in 0..dimensionIndex ~}}
    /// <summary>The {{ xyzw[x] }} component of the vector.</summary>
    [DataMember]
    public readonly T {{ xyzw[x] }};
    {{~ end ~}}

    internal const int Count = {{ vecN }};

    /// <summary>Creates a new <see cref="{{ DocName }}" /> object whose {{ AmountName }} elements have the same value.</summary>
    /// <param name="value">The value to assign to all {{ AmountName }} elements.</param>
    public {{ TypeName }}(T value) : this({{ ['value'] * vecN | array.join ', '}})
    {
    }

    {{~ for smallerVecN in min_dimensions..<vecN ~}}
    /// <summary>Creates a new <see cref="{{ DocName }}" /> object from the specified <see cref="Vector{{vecN}}D{T}" /> object {{ xyzw | array.offset dimensions2 | array.join ' and a ' }} component.</summary>
    /// <param name="value">The vector to use for the {{ xyzw | array.limit dimensions2 | humanizeAnd }} components.</param>
        {{~ for x in xyzw | slice smallerVecN vecN ~}}
    /// <param name="{{ x | string.downcase }}">The {{ x }} component.</param>
        {{~ end ~}}
    public {{ TypeName }}(Vector{{smallerVecN}}D<T> value, {{ Parameters | slice smallerVecN vecN | array.join ', ' }}) : this(
        {{- valueValue 'value.' | slice 0 smallerVecN | array.concat (xyzw | slice smallerVecN vecN | array.each @string.downcase) | array.join ', ' -}}
    )
    {
    }
    {{~ end ~}}

    /// <summary>Creates a vector whose elements have the specified values.</summary>
    {{~ for x in xyzw | array.limit vecN ~}}
    /// <param name="{{ x | string.downcase }}">The value to assign to the <see cref="{{ x }}" /> field.</param>
    {{~ end ~}}
    public {{ TypeName }}({{ Parameters | array.limit vecN | array.join ', ' }})
    {
        Unsafe.SkipInit(out this);

        {{~ for x in xyzw | array.limit vecN ~}}
        {{ x }} = {{ x | string.downcase}};
        {{~ end ~}}
    }

    /// <summary>Constructs a vector from the given <see cref="ReadOnlySpan{T}" />. The span must contain at least 4 elements.</summary>
    /// <param name="values">The span of elements to assign to the vector.</param>
    public {{ TypeName }}(ReadOnlySpan<T> values)
    {
        Unsafe.SkipInit(out this);

        ArgumentOutOfRangeException.ThrowIfLessThan(values.Length, Count, nameof(values));

        this = Unsafe.ReadUnaligned<{{ TypeNameT }}>(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(values)));
    }

    /// <summary>Gets a vector whose 4 elements are equal to zero.</summary>
    /// <value>A vector whose {{ AmountName }} elements are equal to zero (that is, it returns the vector <c>({{ ['0'] * vecN | array.join ',' }})</c>.</value>
    public static {{ TypeNameT }} Zero => new(T.Zero);

    /// <summary>Gets a vector whose 4 elements are equal to one.</summary>
    /// <value>Returns <see cref="{{ DocName }}" />.</value>
    /// <remarks>A vector whose {{ AmountName }} elements are equal to one (that is, it returns the vector <c>({{ ['1'] * vecN | array.join ',' }})</c>.</remarks>
    public static {{ TypeNameT }} One => new(T.One);

    {{~ for x in 0..dimensionIndex ~}}
    {{
        v = ['0'] * vecN
        v[x] = '1';
        v = v | array.join ','

        v2 = ['T.Zero'] * vecN
        v2[x] = 'T.One';
        v2 = v2 | array.join ', '
    -}}
    /// <summary>Gets the vector ({{v}})).</summary>
    /// <value>The vector <c>({{v}})</c>.</value>
    public static {{ TypeNameT }} Unit{{ xyzw[x] }} => new({{v2}});
    {{~ end ~}}

    public ReadOnlySpan<T> Components
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => MemoryMarshal.CreateReadOnlySpan<T>(ref Unsafe.AsRef(in X), Count);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static {{ TypeNameT }} IVector<{{ TypeNameT }}, T>.CreateFromRepeatingComponent(T scalar) => new(scalar);

    /// <summary>Gets or sets the element at the specified index.</summary>
    /// <param name="index">The index of the element to get or set.</param>
    /// <returns>The the element at <paramref name="index" />.</returns>
    /// <exception cref="ArgumentOutOfRangeException"><paramref name="index" /> was less than zero or greater than the number of elements.</exception>
    public T this[int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => Components[index];
    }

    #region Operators
    /// <summary>Adds two vectors together.</summary>
    /// <param name="left">The first vector to add.</param>
    /// <param name="right">The second vector to add.</param>
    /// <returns>The summed vector.</returns>
    /// <remarks>The <see cref="op_Addition" /> method defines the addition operation for <see cref="{{ DocName }}" /> objects.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} operator +({{ TypeNameT }} left, {{ TypeNameT }} right)
    {
        return new {{ TypeNameT }}(
            {{ wrap forEachDimension ','; $"left.{c} + right.{c}"; end }}
        );
    }

    /// <summary>Subtracts the second vector from the first.</summary>
    /// <param name="left">The first vector.</param>
    /// <param name="right">The second vector.</param>
    /// <returns>The vector that results from subtracting <paramref name="right" /> from <paramref name="left" />.</returns>
    /// <remarks>The <see cref="op_Subtraction" /> method defines the subtraction operation for <see cref="{{ DocName }}" /> objects.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} operator -({{ TypeNameT }} left, {{ TypeNameT }} right)
    {
        return new {{ TypeNameT }}(
            {{ wrap forEachDimension ','; $"left.{c} - right.{c}"; end }}
        );
    }

    /// <summary>Negates the specified vector.</summary>
    /// <param name="value">The vector to negate.</param>
    /// <returns>The negated vector.</returns>
    /// <remarks>The <see cref="op_UnaryNegation" /> method defines the unary negation operation for <see cref="{{ DocName }}" /> objects.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} operator -({{ TypeNameT }} value)
    {
        return Zero - value;
    }

    /// <summary>Returns a new vector whose values are the product of each pair of elements in two specified vectors.</summary>
    /// <param name="left">The first vector.</param>
    /// <param name="right">The second vector.</param>
    /// <returns>The element-wise product vector.</returns>
    /// <remarks>The <see cref="{{ DocName }}.op_Multiply" /> method defines the multiplication operation for <see cref="{{ DocName }}" /> objects.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} operator *({{ TypeNameT }} left, {{ TypeNameT }} right)
    {
        return new {{ TypeNameT }}(
            {{ wrap forEachDimension ','; $"left.{c} * right.{c}"; end }}
        );
    }

    /// <summary>Multiplies the specified vector by the specified scalar value.</summary>
    /// <param name="left">The vector.</param>
    /// <param name="right">The scalar value.</param>
    /// <returns>The scaled vector.</returns>
    /// <remarks>The <see cref="{{ DocName }}.op_Multiply" /> method defines the multiplication operation for <see cref="{{ DocName }}" /> objects.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} operator *({{ TypeNameT }} left, T right)
    {
        return left * new {{ TypeNameT }}(right);
    }

    /// <summary>Multiplies the scalar value by the specified vector.</summary>
    /// <param name="left">The vector.</param>
    /// <param name="right">The scalar value.</param>
    /// <returns>The scaled vector.</returns>
    /// <remarks>The <see cref="{{ DocName }}.op_Multiply" /> method defines the multiplication operation for <see cref="{{ DocName }}" /> objects.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} operator *(T left, {{ TypeNameT }} right)
    {
        return right * left;
    }

    /// <summary>Divides the first vector by the second.</summary>
    /// <param name="left">The first vector.</param>
    /// <param name="right">The second vector.</param>
    /// <returns>The vector that results from dividing <paramref name="left" /> by <paramref name="right" />.</returns>
    /// <remarks>The <see cref="{{ DocName }}.op_Division" /> method defines the division operation for <see cref="{{ DocName }}" /> objects.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} operator /({{ TypeNameT }} left, {{ TypeNameT }} right)
    {
        return new {{ TypeNameT }}(
            {{ wrap forEachDimension ','; $"left.{c} / right.{c}"; end }}
        );
    }

    /// <summary>Divides the specified vector by a specified scalar value.</summary>
    /// <param name="value1">The vector.</param>
    /// <param name="value2">The scalar value.</param>
    /// <returns>The result of the division.</returns>
    /// <remarks>The <see cref="{{ DocName }}.op_Division" /> method defines the division operation for <see cref="{{ DocName }}" /> objects.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} operator /({{ TypeNameT }} value1, T value2)
    {
        return value1 / new {{ TypeNameT }}(value2);
    }

    /// <summary>Returns a value that indicates whether each pair of elements in two specified vectors is equal.</summary>
    /// <param name="left">The first vector to compare.</param>
    /// <param name="right">The second vector to compare.</param>
    /// <returns><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <see langword="false" />.</returns>
    /// <remarks>Two <see cref="{{ DocName }}" /> objects are equal if each element in <paramref name="left" /> is equal to the corresponding element in <paramref name="right" />.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator ==({{ TypeNameT }} left, {{ TypeNameT }} right)
    {
        return
            {{ wrap forEachDimension ' &&'; $"left.{c} == right.{c}"; end }};
    }

    /// <summary>Returns a value that indicates whether two specified vectors are not equal.</summary>
    /// <param name="left">The first vector to compare.</param>
    /// <param name="right">The second vector to compare.</param>
    /// <returns><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator !=({{ TypeNameT }} left, {{ TypeNameT }} right)
    {
        return !(left == right);
    }
    #endregion

    #region CopyTo
    /// <summary>Copies the elements of the vector to a specified array.</summary>
    /// <param name="array">The destination array.</param>
    /// <remarks><paramref name="array" /> must have at least {{ AmountName }} elements. The method copies the vector's elements starting at index 0.</remarks>
    /// <exception cref="NullReferenceException"><paramref name="array" /> is <see langword="null" />.</exception>
    /// <exception cref="ArgumentException">The number of elements in the current instance is greater than in the array.</exception>
    /// <exception cref="RankException"><paramref name="array" /> is multidimensional.</exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void CopyTo(T[] array)
    {
        // We explicitly don't check for `null` because historically this has thrown `NullReferenceException` for perf reasons

        ArgumentOutOfRangeException.ThrowIfLessThan(array.Length, Count, nameof(array));

        Unsafe.WriteUnaligned(ref Unsafe.As<T, byte>(ref array[0]), this);
    }

    /// <summary>Copies the elements of the vector to a specified array starting at a specified index position.</summary>
    /// <param name="array">The destination array.</param>
    /// <param name="index">The index at which to copy the first element of the vector.</param>
    /// <remarks><paramref name="array" /> must have a sufficient number of elements to accommodate the {{ AmountName }} vector elements. In other words, elements <paramref name="index" /> through <paramref name="index" /> + {{vecN}} must already exist in <paramref name="array" />.</remarks>
    /// <exception cref="NullReferenceException"><paramref name="array" /> is <see langword="null" />.</exception>
    /// <exception cref="ArgumentException">The number of elements in the current instance is greater than in the array.</exception>
    /// <exception cref="ArgumentOutOfRangeException"><paramref name="index" /> is less than zero.
    /// -or-
    /// <paramref name="index" /> is greater than or equal to the array length.</exception>
    /// <exception cref="RankException"><paramref name="array" /> is multidimensional.</exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void CopyTo(T[] array, int index)
    {
        // We explicitly don't check for `null` because historically this has thrown `NullReferenceException` for perf reasons

        ArgumentOutOfRangeException.ThrowIfGreaterThanOrEqual((uint)index, (uint)array.Length);
        ArgumentOutOfRangeException.ThrowIfLessThan((array.Length - index), Count);

        Unsafe.WriteUnaligned(ref Unsafe.As<T, byte>(ref array[index]), this);
    }

    /// <summary>Copies the vector to the given <see cref="Span{T}" />. The length of the destination span must be at least 4.</summary>
    /// <param name="destination">The destination span which the values are copied into.</param>
    /// <exception cref="ArgumentException">If number of elements in source vector is greater than those available in destination span.</exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void CopyTo(Span<T> destination)
    {
        ArgumentOutOfRangeException.ThrowIfLessThan(destination.Length, Count, nameof(destination));

        Unsafe.WriteUnaligned(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(destination)), this);
    }

    /// <summary>Attempts to copy the vector to the given <see cref="Span{Single}" />. The length of the destination span must be at least 4.</summary>
    /// <param name="destination">The destination span which the values are copied into.</param>
    /// <returns><see langword="true" /> if the source vector was successfully copied to <paramref name="destination" />. <see langword="false" /> if <paramref name="destination" /> is not large enough to hold the source vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryCopyTo(Span<T> destination)
    {
        if (destination.Length < Count)
        {
            return false;
        }

        Unsafe.WriteUnaligned(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(destination)), this);
        return true;
    }
    #endregion

    #region Equality
    /// <summary>Returns a value that indicates whether this instance and another vector are equal.</summary>
    /// <param name="other">The other vector.</param>
    /// <returns><see langword="true" /> if the two vectors are equal; otherwise, <see langword="false" />.</returns>
    /// <remarks>Two vectors are equal if their <see cref="X" />, <see cref="Y" />, <see cref="Z" />, and <see cref="W" /> elements are equal.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool Equals({{ TypeNameT }} other)
    {
        return SpeedHelpers.FastEqualsUpTo4<{{ TypeNameT }}, T>(this, other);
    }

    /// <summary>Returns a value that indicates whether this instance and a specified object are equal.</summary>
    /// <param name="obj">The object to compare with the current instance.</param>
    /// <returns><see langword="true" /> if the current instance and <paramref name="obj" /> are equal; otherwise, <see langword="false" />. If <paramref name="obj" /> is <see langword="null" />, the method returns <see langword="false" />.</returns>
    /// <remarks>The current instance and <paramref name="obj" /> are equal if <paramref name="obj" /> is a <see cref="{{ DocName }}" /> object and their corresponding elements are equal.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public override bool Equals([NotNullWhen(true)] object? obj)
    {
        return (obj is {{ TypeNameT }} other) && Equals(other);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool Equals(Vector{{ vecN }} other)
    {
        if (typeof(T) == typeof(float) && Vector128.IsHardwareAccelerated)
        {
            return Unsafe.BitCast<{{ TypeNameT }}, Vector{{ vecN }}>(this).AsVector128().Equals(other.AsVector128());
        }


        return
            {{
                wrap forEachDimension ' &&'
                    $"float.CreateTruncating({c}).Equals(other.{c})"
                end
            }};
    }

    /// <summary>Returns the hash code for this instance.</summary>
    /// <returns>The hash code.</returns>
    public override int GetHashCode()
    {
        return HashCode.Combine({{ wrap forEachDimension ', ' newline:false; c; end }});
    }
    #endregion

    #region Format
    /// <summary>Returns the string representation of the current instance using default formatting.</summary>
    /// <returns>The string representation of the current instance.</returns>
    /// <remarks>This method returns a string in which each element of the vector is formatted using the "G" (general) format string and the formatting conventions of the current thread culture. The "&lt;" and "&gt;" characters are used to begin and end the string, and the current culture's <see cref="NumberFormatInfo.NumberGroupSeparator" /> property followed by a space is used to separate each element.</remarks>
    public override string ToString()
    {
        return ToString("G", CultureInfo.CurrentCulture);
    }

    /// <summary>Returns the string representation of the current instance using the specified format string to format individual elements.</summary>
    /// <param name="format">A standard or custom numeric format string that defines the format of individual elements.</param>
    /// <returns>The string representation of the current instance.</returns>
    /// <remarks>This method returns a string in which each element of the vector is formatted using <paramref name="format" /> and the current culture's formatting conventions. The "&lt;" and "&gt;" characters are used to begin and end the string, and the current culture's <see cref="NumberFormatInfo.NumberGroupSeparator" /> property followed by a space is used to separate each element.</remarks>
    /// <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">Standard Numeric Format Strings</related>
    /// <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">Custom Numeric Format Strings</related>
    public string ToString([StringSyntax(StringSyntaxAttribute.NumericFormat)] string? format)
    {
        return ToString(format, CultureInfo.CurrentCulture);
    }

    /// <summary>Returns the string representation of the current instance using the specified format string to format individual elements and the specified format provider to define culture-specific formatting.</summary>
    /// <param name="format">A standard or custom numeric format string that defines the format of individual elements.</param>
    /// <param name="formatProvider">A format provider that supplies culture-specific formatting information.</param>
    /// <returns>The string representation of the current instance.</returns>
    /// <remarks>This method returns a string in which each element of the vector is formatted using <paramref name="format" /> and <paramref name="formatProvider" />. The "&lt;" and "&gt;" characters are used to begin and end the string, and the format provider's <see cref="NumberFormatInfo.NumberGroupSeparator" /> property followed by a space is used to separate each element.</remarks>
    /// <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">Standard Numeric Format Strings</related>
    /// <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">Custom Numeric Format Strings</related>
    public string ToString([StringSyntax(StringSyntaxAttribute.NumericFormat)] string? format, IFormatProvider? formatProvider)
    {
        var separator = NumberFormatInfo.GetInstance(formatProvider).NumberGroupSeparator;

        Span<char> initialBuffer = stackalloc char[Math.Min((2 + (Count - 1) + (separator.Length * (Count - 1)) + (Count * 2)), 256)];

        // We can't use an interpolated string here because it won't allow us to pass `format`
        var handler = new DefaultInterpolatedStringHandler(
            4 + (separator.Length * 2),
            Count,
            formatProvider,
            initialBuffer
        );

        handler.AppendLiteral("<");
        {{~ for x in 0..dimensionIndex ~}}
        handler.AppendFormatted({{ xyzw[x] }}, format);
            {{~ if !for.last ~}}
        handler.AppendLiteral(separator);
        handler.AppendLiteral(" ");
            {{~ end ~}}
        {{~ end ~}}
        handler.AppendLiteral(">");

        return handler.ToStringAndClear();
    }

    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        // Possible fast path for failure case:
        // if (destination.Length < 4) return false;

        var separator = NumberFormatInfo.GetInstance(provider).NumberGroupSeparator;

        // We can't use an interpolated string here because it won't allow us to pass `format`
        var handler = new MemoryExtensions.TryWriteInterpolatedStringHandler(
            4 + (separator.Length * 2),
            Count,
            destination,
            provider,
            out var shouldAppend
        );
        if (!shouldAppend)
        {
            charsWritten = 0;
            return false;
        }

        // Annoyingly we need to turn the span into a string for the string handler
        string? formatString = format.Length > 0 ? new string(format) : null;

        _ =
            handler.AppendLiteral("<") &&
            {{~ for x in 0..dimensionIndex ~}}
            handler.AppendFormatted({{ xyzw[x] }}, formatString) &&
                {{~ if !for.last ~}}
            handler.AppendLiteral(separator) &&
            handler.AppendLiteral(" ") &&
                {{~ end ~}}
            {{~ end ~}}
            handler.AppendLiteral(">");

        return destination.TryWrite(ref handler, out charsWritten);
    }
    #endregion

    #region Casts
    public {{ TypeName }}<TOther> As<TOther>() where TOther : INumberBase<TOther>
    {
        if (SpeedHelpers.TryFastConvert<{{ TypeNameT }}, T, {{ TypeName }}<TOther>, TOther>(this, out var result))
        {
            return result;
        }

        return new {{ TypeName }}<TOther>(
            {{ wrap forEachDimension ','; $"TOther.CreateTruncating({c})"; end }}
        );
    }

    private {{ TypeName }}<TOther> AsChecked<TOther>() where TOther : INumberBase<TOther>
    {
        return new {{ TypeName }}<TOther>(
            {{ wrap forEachDimension ','; $"TOther.CreateChecked({c})"; end }}
        );
    }
    public static explicit operator {{ TypeName }}<byte>({{ TypeNameT }} self) => self.As<byte>();
    public static explicit operator {{ TypeName }}<sbyte>({{ TypeNameT }} self) => self.As<sbyte>();
    public static explicit operator {{ TypeName }}<short>({{ TypeNameT }} self) => self.As<short>();
    public static explicit operator {{ TypeName }}<ushort>({{ TypeNameT }} self) => self.As<ushort>();
    public static explicit operator {{ TypeName }}<int>({{ TypeNameT }} self) => self.As<int>();
    public static explicit operator {{ TypeName }}<uint>({{ TypeNameT }} self) => self.As<uint>();
    public static explicit operator {{ TypeName }}<long>({{ TypeNameT }} self) => self.As<long>();
    public static explicit operator {{ TypeName }}<ulong>({{ TypeNameT }} self) => self.As<ulong>();
    public static explicit operator {{ TypeName }}<Int128>({{ TypeNameT }} self) => self.As<Int128>();
    public static explicit operator {{ TypeName }}<UInt128>({{ TypeNameT }} self) => self.As<UInt128>();
    public static explicit operator {{ TypeName }}<Half>({{ TypeNameT }} self) => self.As<Half>();
    public static explicit operator {{ TypeName }}<float>({{ TypeNameT }} self) => self.As<float>();
    public static explicit operator {{ TypeName }}<double>({{ TypeNameT }} self) => self.As<double>();
    public static explicit operator {{ TypeName }}<decimal>({{ TypeNameT }} self) => self.As<decimal>();
    public static explicit operator {{ TypeName }}<Complex>({{ TypeNameT }} self) => self.As<Complex>();
    public static explicit operator {{ TypeName }}<BigInteger>({{ TypeNameT }} self) => self.As<BigInteger>();

    public static explicit operator checked {{ TypeName }}<byte>({{ TypeNameT }} self) => self.AsChecked<byte>();
    public static explicit operator checked {{ TypeName }}<sbyte>({{ TypeNameT }} self) => self.AsChecked<sbyte>();
    public static explicit operator checked {{ TypeName }}<short>({{ TypeNameT }} self) => self.AsChecked<short>();
    public static explicit operator checked {{ TypeName }}<ushort>({{ TypeNameT }} self) => self.AsChecked<ushort>();
    public static explicit operator checked {{ TypeName }}<int>({{ TypeNameT }} self) => self.AsChecked<int>();
    public static explicit operator checked {{ TypeName }}<uint>({{ TypeNameT }} self) => self.AsChecked<uint>();
    public static explicit operator checked {{ TypeName }}<long>({{ TypeNameT }} self) => self.AsChecked<long>();
    public static explicit operator checked {{ TypeName }}<ulong>({{ TypeNameT }} self) => self.AsChecked<ulong>();
    public static explicit operator checked {{ TypeName }}<Int128>({{ TypeNameT }} self) => self.AsChecked<Int128>();
    public static explicit operator checked {{ TypeName }}<UInt128>({{ TypeNameT }} self) => self.AsChecked<UInt128>();
    public static explicit operator checked {{ TypeName }}<Half>({{ TypeNameT }} self) => self.AsChecked<Half>();
    public static explicit operator checked {{ TypeName }}<float>({{ TypeNameT }} self) => self.AsChecked<float>();
    public static explicit operator checked {{ TypeName }}<double>({{ TypeNameT }} self) => self.AsChecked<double>();
    public static explicit operator checked {{ TypeName }}<decimal>({{ TypeNameT }} self) => self.AsChecked<decimal>();
    public static explicit operator checked {{ TypeName }}<Complex>({{ TypeNameT }} self) => self.AsChecked<Complex>();
    public static explicit operator checked {{ TypeName }}<BigInteger>({{ TypeNameT }} self) => self.AsChecked<BigInteger>();

    // Cast to System.Numerics.Vector{{vecN}}
    public static explicit operator Vector{{ vecN }}({{ TypeNameT }} self) => new({{ wrap forEachDimension ', ' newline:false; $"float.CreateTruncating(self.{c})"; end }});
    public static explicit operator checked Vector{{ vecN }}({{ TypeNameT }} self) => new({{ wrap forEachDimension ', ' newline:false; $"float.CreateChecked(self.{c})"; end }});

    // Downcast
    {{~ for dim in min_dimensions..<vecN ~}}
    public static explicit operator Vector{{dim}}D<T>({{ TypeNameT }} self) => new(
        {{- wrap forEachDimension ', ' newline:false dimensionLimit:dim; $"self.{c}"; end -}}
    );
    {{~ end ~}}

    // Upcast
    {{~ if vecN < max_dimensions ~}}
        {{~ for x in (vecN + 1)..max_dimensions ~}}
    public static explicit operator Vector{{x}}D<T>({{ TypeNameT }} self) => new(self, {{ wrap forEachDimension ', ' newline:false dimensionLimit:(x - vecN); $"T.Zero"; end }});
        {{~ end ~}}
    {{~ end ~}}

    // Upcast from System.Numerics.Vector < {{vecN}}
    {{~ for x in min_dimensions..<vecN ~}}
    public static explicit operator {{ TypeNameT }}(Vector{{x}} self) => new(
        {{-
            wrap forEachDimension ', ' newline:false dimensionLimit:x; $"T.CreateTruncating(self.{c})"; end
            ', '
            wrap forEachDimension ', ' newline:false dimensionLimit:(vecN - x); $"T.Zero"; end
        -}}
    );
    public static explicit operator checked {{ TypeNameT }}(Vector{{x}} self) => new(
        {{-
            wrap forEachDimension ', ' newline:false dimensionLimit:x; $"T.CreateChecked(self.{c})"; end
            ', '
            wrap forEachDimension ', ' newline:false dimensionLimit:(vecN - x); $"T.Zero"; end
        -}}
    );
    {{~ end ~}}

    // Downcast from System.Numerics.Vector >= {{vecN}}
    {{~ if vecN < max_dimensions ~}}
        {{~ for x in vecN..max_dimensions ~}}
    public static explicit operator {{ TypeNameT }}(Vector{{x}} self) => new({{ wrap forEachDimension ', ' newline:false; $"T.CreateTruncating(self.{c})"; end }});
    public static explicit operator checked {{ TypeNameT }}(Vector{{x}} self) => new({{ wrap forEachDimension ', ' newline:false; $"T.CreateChecked(self.{c})"; end }});
        {{~ end ~}}
    {{~ end ~}}

    public static implicit operator {{ TypeNameT }}((
        {{- wrap forEachDimension ', ' newline:false; $"T {c}"; end -}}
    ) components)
        => new({{- wrap forEachDimension ', ' newline:false; $"components.{c}"; end -}});

    #endregion

    public void Deconstruct({{ wrap forEachDimension ', ' newline:false; $"out T {cl}"; end }})
    {
        {{ wrap forEachDimension; $"{cl} = {c};"; end }}
    }
}

file interface IVec{{vecN}}
{
    // Returns null if incompatible. Throws OverflowException if overflowing
    {{TypeNameT}}? GetChecked<T>() where T : INumberBase<T>;
    {{TypeNameT}}? GetSaturating<T>() where T : INumberBase<T>;
    {{TypeNameT}}? GetTruncating<T>() where T : INumberBase<T>;
}

// {{ TypeNameT }}.INumber
public readonly partial struct {{TypeNameT}} :
    IDivisionOperators<{{TypeNameT}}, T, {{TypeNameT}}>,
    IMultiplyOperators<{{TypeNameT}}, T, {{TypeNameT}}>,
    INumberBase<{{TypeNameT}}>,
    IVec{{vecN}}
{
    /// <summary>Returns a vector whose elements are the absolute values of each of the specified vector's elements.</summary>
    /// <param name="value">A vector.</param>
    /// <returns>The absolute value vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static {{ TypeNameT }} INumberBase<{{ TypeNameT }}>.Abs({{ TypeNameT }} value) => {{ TypeName }}.Abs(value);

    static {{TypeNameT}} IParsable<{{TypeNameT}}>.Parse(string s, IFormatProvider? provider)
        => Parse(s.AsSpan(), NumberStyles.None, provider);

    static {{TypeNameT}} ISpanParsable<{{TypeNameT}}>.Parse(ReadOnlySpan<char> s, IFormatProvider? provider)
        => Parse(s, NumberStyles.None, provider);

    public static {{TypeNameT}} Parse(string s, NumberStyles style = default, IFormatProvider? provider = null)
        => Parse(s.AsSpan(), style, provider);

    public static {{TypeNameT}} Parse(ReadOnlySpan<char> s, NumberStyles style = NumberStyles.None, IFormatProvider? provider = null)
        => TryParse(s, style, provider, out var result) ? result : throw new ArgumentException($"Failed to parse {nameof(Vector{{vecN}})}<{typeof(T)}>");

    public static bool TryParse(string? s, IFormatProvider? provider, out {{TypeNameT}} result)
        => TryParse(s.AsSpan(), NumberStyles.None, provider, out result);

    public static bool TryParse(string? s, NumberStyles style, IFormatProvider? provider, out {{TypeNameT}} result)
        => TryParse(s.AsSpan(), style, provider, out result);

    public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out {{TypeNameT}} result)
        => TryParse(s, NumberStyles.None, provider, out result);

    public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider, out {{TypeNameT}} result)
    {
        result = default;

        if (s[0] != '<') return false;
        if (s[^1] != '>') return false;

        var separator = NumberFormatInfo.GetInstance(provider).NumberGroupSeparator;

        s = s[1..^1];

        T? {{ xyzw | array.limit vecN | array.join ', ' | string.downcase }};

        {{~ for x in 0..<dimensionIndex ~}}
        {
            if (s.Length == 0) return false;

            var nextNumber = s.IndexOf(separator);
            if (nextNumber == -1)
            {
                return false;
            }

            if (!T.TryParse(s[..nextNumber], style, provider, out {{ xyzw[x] | string.downcase }})) return false;

            s = s[(nextNumber + separator.Length)..];
        }
        {{~ end ~}}

        {
            if (s.Length == 0) return false;

            if (!T.TryParse(s, style, provider, out {{ xyzw[dimensionIndex] | string.downcase }})) return false;
        }

        result = new {{TypeNameT}}({{ wrap forEachDimension ', ' newline:false; cl; end }});
        return true;
    }

    static {{TypeNameT}} IAdditiveIdentity<{{TypeNameT}}, {{TypeNameT}}>.AdditiveIdentity => Zero;
    static {{TypeNameT}} IMultiplicativeIdentity<{{TypeNameT}}, {{TypeNameT}}>.MultiplicativeIdentity => One;

    static {{TypeNameT}} IDecrementOperators<{{TypeNameT}}>.operator --({{TypeNameT}} value) => value - One;
    static {{TypeNameT}} IIncrementOperators<{{TypeNameT}}>.operator ++({{TypeNameT}} value) => value + One;

    static {{TypeNameT}} IUnaryPlusOperators<{{TypeNameT}}, {{TypeNameT}}>.operator +({{TypeNameT}} value) => value;

    static bool INumberBase<{{TypeNameT}}>.IsCanonical({{TypeNameT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsCanonical(value.{c})"; end }};

    static bool INumberBase<{{TypeNameT}}>.IsComplexNumber({{TypeNameT}} value) => {{ wrap forEachDimension ' || ' newline:false; $"T.IsComplexNumber(value.{c})"; end }};

    static bool INumberBase<{{TypeNameT}}>.IsEvenInteger({{TypeNameT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsEvenInteger(value.{c})"; end }};

    static bool INumberBase<{{TypeNameT}}>.IsFinite({{TypeNameT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsFinite(value.{c})"; end }};

    static bool INumberBase<{{TypeNameT}}>.IsImaginaryNumber({{TypeNameT}} value) => {{ wrap forEachDimension ' || ' newline:false; $"T.IsImaginaryNumber(value.{c})"; end }};

    static bool INumberBase<{{TypeNameT}}>.IsInfinity({{TypeNameT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsInfinity(value.{c})"; end }};

    static bool INumberBase<{{TypeNameT}}>.IsInteger({{TypeNameT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsInteger(value.{c})"; end }};

    static bool INumberBase<{{TypeNameT}}>.IsNaN({{TypeNameT}} value) => {{ wrap forEachDimension ' || ' newline:false; $"T.IsNaN(value.{c})"; end }};

    static bool INumberBase<{{TypeNameT}}>.IsNegative({{TypeNameT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsNegative(value.{c})"; end }};

    static bool INumberBase<{{TypeNameT}}>.IsNegativeInfinity({{TypeNameT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsNegativeInfinity(value.{c})"; end }};

    static bool INumberBase<{{TypeNameT}}>.IsNormal({{TypeNameT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsNormal(value.{c})"; end }};

    static bool INumberBase<{{TypeNameT}}>.IsOddInteger({{TypeNameT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsOddInteger(value.{c})"; end }};

    static bool INumberBase<{{TypeNameT}}>.IsPositive({{TypeNameT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsPositive(value.{c})"; end }};

    static bool INumberBase<{{TypeNameT}}>.IsPositiveInfinity({{TypeNameT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsPositiveInfinity(value.{c})"; end }};

    static bool INumberBase<{{TypeNameT}}>.IsRealNumber({{TypeNameT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsRealNumber(value.{c})"; end }};

    static bool INumberBase<{{TypeNameT}}>.IsSubnormal({{TypeNameT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsSubnormal(value.{c})"; end }};

    static bool INumberBase<{{TypeNameT}}>.IsZero({{TypeNameT}} value) => {{ wrap forEachDimension ' && ' newline:false; $"T.IsZero(value.{c})"; end }};

    static {{TypeNameT}} INumberBase<{{TypeNameT}}>.MaxMagnitude({{TypeNameT}} x, {{TypeNameT}} y) => new({{ wrap forEachDimension ', ' newline:false; $"T.MaxMagnitude(x.{c}, y.{c})"; end }});

    static {{TypeNameT}} INumberBase<{{TypeNameT}}>.MaxMagnitudeNumber({{TypeNameT}} x, {{TypeNameT}} y) => new({{ wrap forEachDimension ', ' newline:false; $"T.MaxMagnitudeNumber(x.{c}, y.{c})"; end }});

    static {{TypeNameT}} INumberBase<{{TypeNameT}}>.MinMagnitude({{TypeNameT}} x, {{TypeNameT}} y) => new({{ wrap forEachDimension ', ' newline:false; $"T.MinMagnitude(x.{c}, y.{c})"; end }});

    static {{TypeNameT}} INumberBase<{{TypeNameT}}>.MinMagnitudeNumber({{TypeNameT}} x, {{TypeNameT}} y) => new({{ wrap forEachDimension ', ' newline:false; $"T.MinMagnitudeNumber(x.{c}, y.{c})"; end }});

    public static bool TryConvertFromChecked<TOther>(TOther value, out {{TypeNameT}} result) where TOther : INumberBase<TOther>
    {
        if (value is {{TypeNameT}} v)
        {
            result = v;
            return true;
        }

        if (value is IVec{{vecN}} IVec{{vecN}} && IVec{{vecN}}.GetChecked<T>() is {} r)
        {
            result = r;
            return true;
        }

        result = default;
        return false;
    }

    public static bool TryConvertFromSaturating<TOther>(TOther value, out {{TypeNameT}} result) where TOther : INumberBase<TOther>
    {
        if (value is {{TypeNameT}} v)
        {
            result = v;
            return true;
        }

        if (value is IVec{{vecN}} IVec{{vecN}} && IVec{{vecN}}.GetSaturating<T>() is {} r)
        {
            result = r;
            return true;
        }

        result = default;
        return false;
    }

    public static bool TryConvertFromTruncating<TOther>(TOther value, out {{TypeNameT}} result) where TOther : INumberBase<TOther>
    {
        if (value is {{TypeNameT}} v)
        {
            result = v;
            return true;
        }

        if (value is IVec{{vecN}} IVec{{vecN}} && IVec{{vecN}}.GetTruncating<T>() is {} r)
        {
            result = r;
            return true;
        }

        result = default;
        return false;
    }

    public static bool TryConvertToChecked<TOther>({{TypeNameT}} value, [MaybeNullWhen(false)] out TOther result) where TOther : INumberBase<TOther>
    {
        return TOther.TryConvertFromChecked(value, out result);
    }

    public static bool TryConvertToSaturating<TOther>({{TypeNameT}} value, [MaybeNullWhen(false)] out TOther result) where TOther : INumberBase<TOther>
    {
        return TOther.TryConvertFromSaturating(value, out result);
    }

    public static bool TryConvertToTruncating<TOther>({{TypeNameT}} value, [MaybeNullWhen(false)]out TOther result) where TOther : INumberBase<TOther>
    {
        return TOther.TryConvertFromTruncating(value, out result);
    }

    static int INumberBase<{{TypeNameT}}>.Radix => T.Radix;

    {{TypeName}}<T1>? IVec{{vecN}}.GetChecked<T1>() => T1.TryConvertFromChecked(X, out var x) ? new(x, {{ wrap forEachDimension ', ' newline:false dimensionOffset:1; $"T1.CreateChecked({c})"; end }}) : null;
    {{TypeName}}<T1>? IVec{{vecN}}.GetSaturating<T1>() => T1.TryConvertFromSaturating(X, out var x) ? new(x, {{ wrap forEachDimension ', ' newline:false dimensionOffset:1; $"T1.CreateSaturating({c})"; end }}) : null;
    {{TypeName}}<T1>? IVec{{vecN}}.GetTruncating<T1>() => T1.TryConvertFromTruncating(X, out var x) ? new(x, {{ wrap forEachDimension ', ' newline:false dimensionOffset:1; $"T1.CreateTruncating({c})"; end }}) : null;
}

// {{ TypeNameT }}.IReadOnlyList
public readonly partial struct {{ TypeNameT }} : IReadOnlyList<T>
{
    IEnumerator<T> IEnumerable<T>.GetEnumerator()
    {
        {{ wrap forEachDimension; $"yield return {c};"; end }}
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return ((IEnumerable<T>)this).GetEnumerator();
    }

    int IReadOnlyCollection<T>.Count => Count;
}

// {{ TypeNameT }}.IUtf8SpanParsableFormattable
public partial struct {{ TypeNameT }} :
    IUtf8SpanFormattable,
    IUtf8SpanParsable<{{ TypeNameT }}>
{
    public bool TryFormat(Span<byte> utf8Destination, out int bytesWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        // Possible fast path for failure case:
        // if (destination.Length < 4) return false;

        var separator = NumberFormatInfo.GetInstance(provider).NumberGroupSeparator;

        // We can't use an interpolated string here because it won't allow us to pass `format`
        var handler = new Utf8.TryWriteInterpolatedStringHandler(
            4 + (separator.Length * 2),
            Count,
            utf8Destination,
            provider,
            out var shouldAppend
        );
        if (!shouldAppend)
        {
            bytesWritten = 0;
            return false;
        }

        // Annoyingly we need to turn the span into a string for the string handler
        string? formatString = format.Length > 0 ? new string(format) : null;

        // JIT will automagically convert literals to utf8
        _ =
            handler.AppendLiteral("<") &&
            {{~ for x in 0..dimensionIndex ~}}
            handler.AppendFormatted({{ xyzw[x] }}, formatString) &&
                {{~ if x < dimensionIndex ~}}
            handler.AppendLiteral(separator) &&
            handler.AppendLiteral(" ") &&
                {{~ end ~}}
            {{~ end ~}}
            handler.AppendLiteral(">");

        return Utf8.TryWrite(utf8Destination, ref handler, out bytesWritten);
    }

    public static {{ TypeNameT }} Parse(ReadOnlySpan<byte> utf8Text, IFormatProvider? provider)
        => TryParse(utf8Text, provider, out var result) ? result : throw new ArgumentException($"Failed to parse {nameof({{TypeName}})}<{typeof(T)}>");

    public static bool TryParse(ReadOnlySpan<byte> s, IFormatProvider? provider, out {{ TypeNameT }} result)
    {
        result = default;

        if (s[0] != (byte)'<') return false;
        if (s[^1] != (byte)'>') return false;

        var separator = NumberGroupSeparatorTChar<byte>(NumberFormatInfo.GetInstance(provider));

        s = s[1..^1];

        T? {{ xyzw | array.limit vecN | array.join ', ' | string.downcase }};

        {{~ for x in 0..<(vecN - 1) ~}}
        {
            if (s.Length == 0) return false;

            var nextNumber = s.IndexOf(separator);
            if (nextNumber == -1)
            {
                return false;
            }

            if (!T.TryParse(s[..nextNumber], provider, out {{ xyzw[x] | string.downcase }})) return false;

            s = s[(nextNumber + separator.Length)..];
        }
        {{~ end ~}}

        {
            if (s.Length == 0) return false;

            if (!T.TryParse(s, provider, out {{ xyzw[vecN-1] | string.downcase }})) return false;
        }

        result = new {{TypeNameT}}({{ xyzw | array.limit vecN | array.join ', ' | string.downcase }});
        return true;

        [UnsafeAccessor(UnsafeAccessorKind.Method, Name = nameof(NumberGroupSeparatorTChar))]
        static extern ReadOnlySpan<TChar> NumberGroupSeparatorTChar<TChar>(NumberFormatInfo? c) where TChar : unmanaged;
    }
}

// {{ TypeName }}
public static partial class {{ TypeName }}
{
    #region Extension

    /// <summary>Returns the length of this vector object.</summary>
    /// <returns>The vector's length.</returns>
    /// <altmember cref="LengthSquared{T,TReturn}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TReturn Length<T, TReturn>(this {{ TypeNameT }} vec) where T : INumberBase<T> where TReturn : INumberBase<TReturn>, IRootFunctions<TReturn>
    {
        var lengthSquared = vec.LengthSquared<T, TReturn>();
        return TReturn.Sqrt(lengthSquared);
    }

    /// <summary>Returns the length of the vector squared.</summary>
    /// <returns>The vector's length squared.</returns>
    /// <remarks>This operation offers better performance than a call to the <see cref="Length{T,TReturn}" /> method.</remarks>
    /// <altmember cref="Length{T,TReturn}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TReturn LengthSquared<T, TReturn>(this {{ TypeNameT }} vec) where T : INumberBase<T> where TReturn : INumberBase<TReturn>
    {
        return Dot<T, TReturn>(vec, vec);
    }

    #endregion

    #region Basic

    /// <summary>Returns a new vector whose values are the product of each pair of elements in two specified vectors.</summary>
    /// <param name="left">The first vector.</param>
    /// <param name="right">The second vector.</param>
    /// <returns>The element-wise product vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Multiply<T>({{ TypeNameT }} left, {{ TypeNameT }} right) where T : INumberBase<T>
    {
        return left * right;
    }

    /// <summary>Multiplies a vector by a specified scalar.</summary>
    /// <param name="left">The vector to multiply.</param>
    /// <param name="right">The scalar value.</param>
    /// <returns>The scaled vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Multiply<T>({{ TypeNameT }} left, T right) where T : INumberBase<T>
    {
        return left * right;
    }

    /// <summary>Multiplies a scalar value by a specified vector.</summary>
    /// <param name="left">The scaled value.</param>
    /// <param name="right">The vector.</param>
    /// <returns>The scaled vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Multiply<T>(T left, {{ TypeNameT }} right) where T : INumberBase<T>
    {
        return left * right;
    }

    /// <summary>Negates a specified vector.</summary>
    /// <param name="value">The vector to negate.</param>
    /// <returns>The negated vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Negate<T>({{ TypeNameT }} value) where T : INumberBase<T>
    {
        return -value;
    }

    /// <summary>Subtracts the second vector from the first.</summary>
    /// <param name="left">The first vector.</param>
    /// <param name="right">The second vector.</param>
    /// <returns>The difference vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Subtract<T>({{ TypeNameT }} left, {{ TypeNameT }} right) where T : INumberBase<T>
    {
        return left - right;
    }

    /// <summary>Adds two vectors together.</summary>
    /// <param name="left">The first vector to add.</param>
    /// <param name="right">The second vector to add.</param>
    /// <returns>The summed vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Add<T>({{ TypeNameT }} left, {{ TypeNameT }} right) where T : INumberBase<T>
    {
        return left + right;
    }

    /// <summary>Divides the first vector by the second.</summary>
    /// <param name="left">The first vector.</param>
    /// <param name="right">The second vector.</param>
    /// <returns>The vector resulting from the division.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Divide<T>({{ TypeNameT }} left, {{ TypeNameT }} right) where T : INumberBase<T>
    {
        return left / right;
    }

    /// <summary>Divides the specified vector by a specified scalar value.</summary>
    /// <param name="left">The vector.</param>
    /// <param name="divisor">The scalar value.</param>
    /// <returns>The vector that results from the division.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Divide<T>({{ TypeNameT }} left, T divisor) where T : INumberBase<T>
    {
        return left / divisor;
    }

    #endregion

    #region Other

    /// <summary>Returns a vector whose elements are the absolute values of each of the specified vector's elements.</summary>
    /// <param name="value">A vector.</param>
    /// <returns>The absolute value vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Abs<T>({{ TypeNameT }} value) where T : INumberBase<T> => new({{ repeatCall 'T.Abs' 'value' }});

    /// <summary>Restricts a vector between a minimum and a maximum value.</summary>
    /// <param name="value1">The vector to restrict.</param>
    /// <param name="min">The minimum value.</param>
    /// <param name="max">The maximum value.</param>
    /// <returns>The restricted vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Clamp<T>({{ TypeNameT }} value1, {{ TypeNameT }} min, {{ TypeNameT }} max) where T : INumberBase<T>, IComparisonOperators<T, T, bool>
    {
        // We must follow HLSL behavior in the case user specified min value is bigger than max value.
        return Min(Max(value1, min), max);
    }

    /// <summary>Computes the Euclidean distance between the two given points.</summary>
    /// <param name="value1">The first point.</param>
    /// <param name="value2">The second point.</param>
    /// <returns>The distance.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TReturn Distance<T, TReturn>({{ TypeNameT }} value1, {{ TypeNameT }} value2) where T : INumberBase<T> where TReturn : INumberBase<TReturn>, IRootFunctions<TReturn>
    {
        var distanceSquared = DistanceSquared<T, TReturn>(value1, value2);
        return TReturn.Sqrt(distanceSquared);
    }

    /// <summary>Returns the Euclidean distance squared between two specified points.</summary>
    /// <param name="value1">The first point.</param>
    /// <param name="value2">The second point.</param>
    /// <returns>The distance squared.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T DistanceSquared<T>({{ TypeNameT }} value1, {{ TypeNameT }} value2) where T : INumberBase<T>
    {
        var difference = value1 - value2;
        return Dot(difference, difference);
    }

    /// <summary>Returns the Euclidean distance squared between two specified points.</summary>
    /// <param name="value1">The first point.</param>
    /// <param name="value2">The second point.</param>
    /// <returns>The distance squared.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TReturn DistanceSquared<T, TReturn>({{ TypeNameT }} value1, {{ TypeNameT }} value2) where T : INumberBase<T> where TReturn : INumberBase<TReturn>
    {
        var difference = value1 - value2;
        return Dot<T, TReturn>(difference, difference);
    }

    /// <summary>Returns the dot product of two vectors.</summary>
    /// <param name="vector1">The first vector.</param>
    /// <param name="vector2">The second vector.</param>
    /// <returns>The dot product.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Dot<T>({{ TypeNameT }} vector1, {{ TypeNameT }} vector2) where T : INumberBase<T>
    {
        return
            {{ wrap forEachDimension ' +'; $"vector1.{c} * vector2.{c}"; end -}};
    }

    /// <summary>Returns the dot product of two vectors.</summary>
    /// <param name="vector1">The first vector.</param>
    /// <param name="vector2">The second vector.</param>
    /// <returns>The dot product.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TReturn Dot<T, TReturn>({{ TypeNameT }} vector1, {{ TypeNameT }} vector2) where T : INumberBase<T> where TReturn : INumberBase<TReturn>
    {
        return
            {{ wrap forEachDimension ' +'; $"TReturn.CreateTruncating(vector1.{c}) * TReturn.CreateTruncating(vector2.{c})"; end -}};
    }

    /// <summary>Performs a linear interpolation between two vectors based on the given weighting.</summary>
    /// <param name="value1">The first vector.</param>
    /// <param name="value2">The second vector.</param>
    /// <param name="amount">A value between 0 and 1 that indicates the weight of <paramref name="value2" />.</param>
    /// <returns>The interpolated vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeName }}<TFloat> Lerp<T, TFloat>({{ TypeNameT }} value1, {{ TypeNameT }} value2, TFloat amount) where T : INumberBase<T> where TFloat : INumberBase<TFloat>, IFloatingPoint<TFloat>
    {
        return (value1.As<TFloat>() * (TFloat.One - amount)) + (value2.As<TFloat>() * amount);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeName }}<TFloat> LerpClamped<T, TFloat>({{ TypeNameT }} value1, {{ TypeNameT }} value2, TFloat amount) where T : INumberBase<T> where TFloat : INumberBase<TFloat>, IFloatingPoint<TFloat>
    {
        amount = TFloat.Clamp(amount, TFloat.Zero, TFloat.One);
        return Lerp(value1, value2, amount);
    }

    /// <summary>Returns a vector whose elements are the maximum of each of the pairs of elements in two specified vectors.</summary>
    /// <param name="value1">The first vector.</param>
    /// <param name="value2">The second vector.</param>
    /// <returns>The maximized vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Max<T>({{ TypeNameT }} value1, {{ TypeNameT }} value2) where T : INumberBase<T>, IComparisonOperators<T, T, bool>
    {
        return new {{ TypeNameT }}( // using T.Max here would add an IsNaN check
            {{ wrap forEachDimension ', '; $"(value1.{c} > value2.{c}) ? value1.{c} : value2.{c}"; end }}
        );
    }

    /// <summary>Returns a vector whose elements are the minimum of each of the pairs of elements in two specified vectors.</summary>
    /// <param name="value1">The first vector.</param>
    /// <param name="value2">The second vector.</param>
    /// <returns>The minimized vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Min<T>({{ TypeNameT }} value1, {{ TypeNameT }} value2) where T : INumberBase<T>, IComparisonOperators<T, T, bool>
    {
        return new {{ TypeNameT }}( // using T.Min here would add an IsNaN check
            {{ wrap forEachDimension ', '; $"(value1.{c} < value2.{c}) ? value1.{c} : value2.{c}"; end }}
        );
    }

    /// <summary>Returns a vector with the same direction as the specified vector, but with a length of one.</summary>
    /// <param name="value">The vector to normalize.</param>
    /// <returns>The normalized vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeName }}<TReturn> Normalize<T, TReturn>({{ TypeNameT }} value) where T : INumberBase<T> where TReturn : INumberBase<TReturn>, IRootFunctions<TReturn>
    {
        return value.As<TReturn>() / value.Length<T, TReturn>();
    }

    /// <summary>Returns a vector with the same direction as the specified vector, but with a length of one.</summary>
    /// <param name="value">The vector to normalize.</param>
    /// <returns>The normalized vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Normalize<T>({{ TypeNameT }} value) where T : INumberBase<T>, IRootFunctions<T>
    {
        return value / value.Length();
    }

    /// <summary>Returns the reflection of a vector off a surface that has the specified normal.</summary>
    /// <param name="vector">The source vector.</param>
    /// <param name="normal">The normal of the surface being reflected off.</param>
    /// <returns>The reflected vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeName }}<TReturn> Reflect<T, TReturn>({{ TypeNameT }} vector, {{ TypeNameT }} normal) where T : INumberBase<T> where TReturn : INumberBase<TReturn>
    {
        var dot = Dot<T, TReturn>(vector, normal);
        return vector.As<TReturn>() - (NumericConstants<TReturn>.Two * (dot * normal.As<TReturn>()));
    }

    /// <summary>Returns a vector whose elements are the square root of each of a specified vector's elements.</summary>
    /// <param name="value">A vector.</param>
    /// <returns>The square root vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeName }}<TReturn> Sqrt<T, TReturn>({{ TypeNameT }} value) where T : INumberBase<T> where TReturn : INumberBase<TReturn>, IRootFunctions<TReturn>
    {
        return new {{ TypeName }}<TReturn>(
            {{ wrap forEachDimension ', '; $"TReturn.Sqrt(TReturn.CreateTruncating(value.{c}))"; end }}
        );
    }

    // CANNOT BE DONE
    /*
    /// <summary>Transforms a vector by a specified 4x4 matrix.</summary>
    /// <param name="position">The vector to transform.</param>
    /// <param name="matrix">The transformation matrix.</param>
    /// <returns>The transformed vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Transform<T>({{ TypeNameT }} position, Matrix4X4<T> matrix) where T : INumberBase<T>
    {
        return ({{ TypeNameT }})Vector4D.Transform(position, matrix);
    }

    /// <summary>Transforms a vector by the specified Quaternion rotation value.</summary>
    /// <param name="value">The vector to rotate.</param>
    /// <param name="rotation">The rotation to apply.</param>
    /// <returns>The transformed vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeName }}<TReturn> Transform<T, TQuat, TReturn>({{ TypeNameT }} value, Quaternion<TQuat> rotation) where T : INumberBase<T> where TReturn : INumberBase<TReturn> where TQuat : ITrigonometricFunctions<TQuat>, IRootFunctions<TQuat>
    {
        {{ wrap forEachDimension; $"var {cl2} = rotation.{c} + rotation.{c};"; end -}}
        var x2 = rotation.X + rotation.X;
        var y2 = rotation.Y + rotation.Y;
        var z2 = rotation.Z + rotation.Z;

        {{~

        func forEachDimensionSquared(sep = null, newline = true, endingNewline = false, dimensionLimit = null, dimensionOffset = null)
            dimensionLimit = (dimensionLimit ?? vecN) - 1
            dimensionOffset = dimensionOffset ?? 0
            for x in dimensionOffset..dimensionLimit
                for y in dimensionOffset..dimensionLimit
                    c = xyzw[x]
                    cl = c | string.downcase
                    d = xyzw[y]
                    dl = d | string.downcase
                    $$
                    if !for.last && sep != null
                        sep
                    end
                    if newline && (endingNewline || !for.last)
                        '\n'
                    end
                end
            end
        end

        ~}}

        {{ wrap forEachDimension; $"var {cl2} = rotation.{c} + rotation.{c};"; end -}}

        var wx2 = TReturn.CreateTruncating(rotation.W * x2);
        var wy2 = TReturn.CreateTruncating(rotation.W * y2);
        var wz2 = TReturn.CreateTruncating(rotation.W * z2);
        var xx2 = TReturn.CreateTruncating(rotation.X * x2);
        var xy2 = TReturn.CreateTruncating(rotation.X * y2);
        var xz2 = TReturn.CreateTruncating(rotation.X * z2);
        var yy2 = TReturn.CreateTruncating(rotation.Y * y2);
        var yz2 = TReturn.CreateTruncating(rotation.Y * z2);
        var zz2 = TReturn.CreateTruncating(rotation.Z * z2);

        return new {{ TypeName }}<TReturn>(
            {{ wrap forEachDimension ', '; $"TReturn.Sqrt(TReturn.CreateTruncating(value.{c}))"; end }}
        );

        return new {{ TypeName }}<TReturn>(
            TReturn.CreateTruncating(value.X) * (TReturn.One - yy2 - zz2) + TReturn.CreateTruncating(value.Y) * (xy2 - wz2) + TReturn.CreateTruncating(value.Z) * (xz2 + wy2),
            TReturn.CreateTruncating(value.X) * (xy2 + wz2) + TReturn.CreateTruncating(value.Y) * (TReturn.One - xx2 - zz2) + TReturn.CreateTruncating(value.Z) * (yz2 - wx2),
            TReturn.CreateTruncating(value.X) * (xz2 - wy2) + TReturn.CreateTruncating(value.Y) * (yz2 + wx2) + TReturn.CreateTruncating(value.Z) * (TReturn.One - xx2 - yy2)
        );
    }

    // /// <summary>Transforms a vector normal by the given 4x4 matrix.</summary>
    // /// <param name="normal">The source vector.</param>
    // /// <param name="matrix">The matrix.</param>
    // /// <returns>The transformed vector.</returns>
    // [MethodImpl(MethodImplOptions.AggressiveInlining)]
    // internal static {{ TypeNameT }} TransformNormal<T>({{ TypeNameT }} normal, in Matrix4x4 matrix) where T : INumberBase<T>
    // {
    //     var matrixX = new Vector4(matrix.M11, matrix.M12, matrix.M13, matrix.M14);
    //     var matrixY = new Vector4(matrix.M21, matrix.M22, matrix.M23, matrix.M24);
    //     var matrixZ = new Vector4(matrix.M31, matrix.M32, matrix.M33, matrix.M34);
    //     // var matrixW = new Vector4(matrix.M41, matrix.M42, matrix.M43, matrix.M44);
    //
    //     var result = matrixX * normal.X;
    //     result += matrixY * normal.Y;
    //     result += matrixZ * normal.Z;
    //     return result.AsVector128().AsVector3();
    // }
    */

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Remainder<T>(this {{ TypeNameT }} left, {{ TypeNameT }} right) where T : INumberBase<T>, IModulusOperators<T, T, T>
    {
        return new {{ TypeNameT }}(
            {{ wrap forEachDimension ','; $"left.{c} % right.{c}"; end }}
        );
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Remainder<T>(this {{ TypeNameT }} left, T right) where T : INumberBase<T>, IModulusOperators<T, T, T>
    {
        return new {{ TypeNameT }}(
            {{ wrap forEachDimension ','; $"left.{c} % right"; end }}
        );
    }
    #endregion

    #region Specializations

    /// <summary>Returns the length of this vector object.</summary>
    /// <returns>The vector's length.</returns>
    /// <altmember cref="LengthSquared{T}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Length<T>(this {{ TypeNameT }} vec) where T : INumberBase<T>, IRootFunctions<T>
    {
        return vec.Length<T, T>();
    }

    /// <summary>Returns the length of the vector squared.</summary>
    /// <returns>The vector's length squared.</returns>
    /// <remarks>This operation offers better performance than a call to the <see cref="Length{T}" /> method.</remarks>
    /// <altmember cref="Length{T}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T LengthSquared<T>(this {{ TypeNameT }} vec) where T : INumberBase<T>
    {
        return vec.LengthSquared<T, T>();
    }

    /// <summary>Performs a linear interpolation between two vectors based on the given weighting.</summary>
    /// <param name="value1">The first vector.</param>
    /// <param name="value2">The second vector.</param>
    /// <param name="amount">A value between 0 and 1 that indicates the weight of <paramref name="value2" />.</param>
    /// <returns>The interpolated vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Lerp<T>({{ TypeNameT }} value1, {{ TypeNameT }} value2, T amount) where T : INumberBase<T>, IFloatingPoint<T>
    {
        return Lerp<T, T>(value1, value2, amount);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} LerpClamped<T>({{ TypeNameT }} value1, {{ TypeNameT }} value2, T amount) where T : INumberBase<T>, IFloatingPoint<T>
    {
        return LerpClamped<T, T>(value1, value2, amount);
    }

    /// <summary>Returns the reflection of a vector off a surface that has the specified normal.</summary>
    /// <param name="vector">The source vector.</param>
    /// <param name="normal">The normal of the surface being reflected off.</param>
    /// <returns>The reflected vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Reflect<T>({{ TypeNameT }} vector, {{ TypeNameT }} normal) where T : IFloatingPoint<T>
    {
        return Reflect<T, T>(vector, normal);
    }

    /// <summary>Returns a vector whose elements are the square root of each of a specified vector's elements.</summary>
    /// <param name="value">A vector.</param>
    /// <returns>The square root vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Sqrt<T>({{ TypeNameT }} value) where T : IFloatingPoint<T>, IRootFunctions<T>
    {
        return Sqrt<T, T>(value);
    }

    // CANNOT BE DONE
    /*
    /// <summary>Transforms a vector by the specified Quaternion rotation value.</summary>
    /// <param name="value">The vector to rotate.</param>
    /// <param name="rotation">The rotation to apply.</param>
    /// <returns>The transformed vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Transform<T>({{ TypeNameT }} value, Quaternion<T> rotation)
        where T : IFloatingPoint<T>, ITrigonometricFunctions<T>, IRootFunctions<T>
    {
        return Transform<T, T, T>(value, rotation);
    }


    /// <summary>Transforms a vector by the specified Quaternion rotation value.</summary>
    /// <param name="value">The vector to rotate.</param>
    /// <param name="rotation">The rotation to apply.</param>
    /// <returns>The transformed vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Transform<T, TQuat>({{ TypeNameT }} value, Quaternion<TQuat> rotation)
        where T : IFloatingPoint<T>
        where TQuat : ITrigonometricFunctions<TQuat>, IRootFunctions<TQuat>
    {
        return Transform<T, TQuat, T>(value, rotation);
    }
    */
    #endregion

    // Equivalent implementing IHyperbolicFunctions<System.Runtime.Intrinsics.Vector3>
    public static {{ TypeNameT }} Acosh<T>({{ TypeNameT }} x) where T : IHyperbolicFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Acosh(x.{c})"; end }});
    public static {{ TypeNameT }} Asinh<T>({{ TypeNameT }} x) where T : IHyperbolicFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Asinh(x.{c})"; end }});
    public static {{ TypeNameT }} Atanh<T>({{ TypeNameT }} x) where T : IHyperbolicFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Atanh(x.{c})"; end }});
    public static {{ TypeNameT }} Cosh<T>({{ TypeNameT }} x) where T : IHyperbolicFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Cosh(x.{c})"; end }});
    public static {{ TypeNameT }} Sinh<T>({{ TypeNameT }} x) where T : IHyperbolicFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Sinh(x.{c})"; end }});
    public static {{ TypeNameT }} Tanh<T>({{ TypeNameT }} x) where T : IHyperbolicFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Tanh(x.{c})"; end }});

    // Equivalent implementing ITrigonometricFunctions<System.Runtime.Intrinsics.Vector3>
    public static {{ TypeNameT }} Acos<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Acos(x.{c})"; end }});
    public static {{ TypeNameT }} AcosPi<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.AcosPi(x.{c})"; end }});
    public static {{ TypeNameT }} Asin<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Asin(x.{c})"; end }});
    public static {{ TypeNameT }} AsinPi<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.AsinPi(x.{c})"; end }});
    public static {{ TypeNameT }} Atan<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Atan(x.{c})"; end }});
    public static {{ TypeNameT }} AtanPi<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.AtanPi(x.{c})"; end }});
    public static {{ TypeNameT }} Cos<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Cos(x.{c})"; end }});
    public static {{ TypeNameT }} CosPi<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.CosPi(x.{c})"; end }});
    public static {{ TypeNameT }} DegreesToRadians<T>({{ TypeNameT }} degrees) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.DegreesToRadians(degrees.{c})"; end }});
    public static {{ TypeNameT }} RadiansToDegrees<T>({{ TypeNameT }} radians) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.RadiansToDegrees(radians.{c})"; end }});
    public static {{ TypeNameT }} Sin<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Sin(x.{c})"; end }});
    public static {{ TypeNameT }} SinPi<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.SinPi(x.{c})"; end }});
    public static {{ TypeNameT }} Tan<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Tan(x.{c})"; end }});
    public static {{ TypeNameT }} TanPi<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.TanPi(x.{c})"; end }});


    public static ({{ TypeNameT }} Sin, {{ TypeNameT }} Cos) SinCos<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T>
    {
        {{ wrap forEachDimension; $"var (sin{c}, cos{c}) = T.SinCos(x.{c});"; end }}

        return (
            new {{ TypeNameT }}({{- wrap forEachDimension ', ' newline:false; $"sin{c}"; end -}}),
            new {{ TypeNameT }}({{- wrap forEachDimension ', ' newline:false; $"cos{c}"; end -}})
        );
    }

    public static ({{ TypeNameT }} SinPi, {{ TypeNameT }} CosPi) SinCosPi<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T>
    {
        {{ wrap forEachDimension; $"var (sin{c}, cos{c}) = T.SinCosPi(x.{c});"; end }}

        return (
            new {{ TypeNameT }}({{- wrap forEachDimension ', ' newline:false; $"sin{c}"; end -}}),
            new {{ TypeNameT }}({{- wrap forEachDimension ', ' newline:false; $"cos{c}"; end -}})
        );
    }

    // Equivalent implementing ILogarithmicFunctions<System.Runtime.Intrinsics.Vector3>
    public static {{ TypeNameT }} Log<T>({{ TypeNameT }} x) where T : ILogarithmicFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Log(x.{c})"; end }});

    public static {{ TypeNameT }} Log<T>({{ TypeNameT }} x, {{ TypeNameT }} newBase) where T : ILogarithmicFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Log(x.{c}, newBase.{c})"; end }});
    public static {{ TypeNameT }} Log<T>({{ TypeNameT }} x, T newBase) where T : ILogarithmicFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Log(x.{c}, newBase)"; end }});
    public static {{ TypeNameT }} LogP1<T>({{ TypeNameT }} x) where T : ILogarithmicFunctions<T> => Log(x + {{ TypeNameT }}.One);
    public static {{ TypeNameT }} Log2<T>({{ TypeNameT }} x) where T : ILogarithmicFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Log2(x.{c})"; end }});
    public static {{ TypeNameT }} Log2P1<T>({{ TypeNameT }} x) where T : ILogarithmicFunctions<T> => Log2(x + {{ TypeNameT }}.One);
    public static {{ TypeNameT }} Log10<T>({{ TypeNameT }} x) where T : ILogarithmicFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Log10(x.{c})"; end }});
    public static {{ TypeNameT }} Log10P1<T>({{ TypeNameT }} x) where T : ILogarithmicFunctions<T> => Log10(x + {{ TypeNameT }}.One);

    // Equivalent implementing IExponentialFunctions<System.Runtime.Intrinsics.Vector3>
    public static {{ TypeNameT }} Exp<T>({{ TypeNameT }} x) where T : IExponentialFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Exp(x.{c})"; end }});
    public static {{ TypeNameT }} ExpM1<T>({{ TypeNameT }} x) where T : IExponentialFunctions<T> => Exp(x) - {{ TypeNameT }}.One;
    public static {{ TypeNameT }} Exp2<T>({{ TypeNameT }} x) where T : IExponentialFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Exp2(x.{c})"; end }});
    public static {{ TypeNameT }} Exp2M1<T>({{ TypeNameT }} x) where T : IExponentialFunctions<T> => Exp2(x) - {{ TypeNameT }}.One;
    public static {{ TypeNameT }} Exp10<T>({{ TypeNameT }} x) where T : IExponentialFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Exp10(x.{c})"; end }});
    public static {{ TypeNameT }} Exp10M1<T>({{ TypeNameT }} x) where T : IExponentialFunctions<T> => Exp10(x) - {{ TypeNameT }}.One;

    // Equivalent implementing IPowerFunctions<System.Runtime.Intrinsics.Vector3>
    public static {{ TypeNameT }} Pow<T>({{ TypeNameT }} x, {{ TypeNameT }} y) where T : IPowerFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Pow(x.{c}, y.{c})"; end }});
    public static {{ TypeNameT }} Pow<T>({{ TypeNameT }} x, T y) where T : IPowerFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Pow(x.{c}, y)"; end }});

    // Equivalent implementing IRootFunctions<System.Runtime.Intrinsics.Vector3>
    public static {{ TypeNameT }} Cbrt<T>({{ TypeNameT }} x) where T : IRootFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Cbrt(x.{c})"; end }});
    public static {{ TypeNameT }} Hypot<T>({{ TypeNameT }} x, {{ TypeNameT }} y) where T : IRootFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Hypot(x.{c}, y.{c})"; end }});
    public static {{ TypeNameT }} Hypot<T>({{ TypeNameT }} x, T y) where T : IRootFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Hypot(x.{c}, y)"; end }});
    public static {{ TypeNameT }} RootN<T>({{ TypeNameT }} x, int n) where T : IRootFunctions<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.RootN(x.{c}, n)"; end }});

    // IFloatingPoint<TSelf>
    public static {{ TypeNameT }} Round<T>({{ TypeNameT }} x) where T : IFloatingPoint<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Round(x.{c})"; end }});
    public static {{ TypeNameT }} Round<T>({{ TypeNameT }} x, int digits) where T : IFloatingPoint<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Round(x.{c}, digits)"; end }});
    public static {{ TypeNameT }} Round<T>({{ TypeNameT }} x, MidpointRounding mode) where T : IFloatingPoint<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Round(x.{c}, mode)"; end }});
    public static {{ TypeNameT }} Round<T>({{ TypeNameT }} x, int digits, MidpointRounding mode) where T : IFloatingPoint<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Round(x.{c}, digits, mode)"; end }});
    public static {{ TypeNameT }} Truncate<T>({{ TypeNameT }} x) where T : IFloatingPoint<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Truncate(x.{c})"; end }});

    // IFloatingPointIeee754<TSelf>
    public static {{ TypeNameT }} Atan2<T>({{ TypeNameT }} x, {{ TypeNameT }} y) where T : IFloatingPointIeee754<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Atan2(x.{c}, y.{c})"; end }});
    public static {{ TypeNameT }} Atan2Pi<T>({{ TypeNameT }} x, {{ TypeNameT }} y) where T : IFloatingPointIeee754<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Atan2Pi(x.{c}, y.{c})"; end }});
    public static {{ TypeNameT }} Atan2<T>({{ TypeNameT }} x, T y) where T : IFloatingPointIeee754<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Atan2(x.{c}, y)"; end }});
    public static {{ TypeNameT }} Atan2Pi<T>({{ TypeNameT }} x, T y) where T : IFloatingPointIeee754<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Atan2Pi(x.{c}, y)"; end }});
    public static {{ TypeNameT }} BitDecrement<T>({{ TypeNameT }} x) where T : IFloatingPointIeee754<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.BitDecrement(x.{c})"; end }});
    public static {{ TypeNameT }} BitIncrement<T>({{ TypeNameT }} x) where T : IFloatingPointIeee754<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.BitIncrement(x.{c})"; end }});

    public static {{ TypeNameT }} FusedMultiplyAdd<T>({{ TypeNameT }} left, {{ TypeNameT }} right, {{ TypeNameT }} addend) where T : IFloatingPointIeee754<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.FusedMultiplyAdd(left.{c}, right.{c}, addend.{c})"; end }});
    // public static {{ TypeNameT }} Lerp<T>({{ TypeNameT }} value1, {{ TypeNameT }} value2, {{ TypeNameT }} amount) where T : IFloatingPointIeee754<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Lerp(value1.{c}, value2.{c}, amount.{c})"; end }});
    public static {{ TypeNameT }} ReciprocalEstimate<T>({{ TypeNameT }} x) where T : IFloatingPointIeee754<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.ReciprocalEstimate(x.{c})"; end }});
    public static {{ TypeNameT }} ReciprocalSqrtEstimate<T>({{ TypeNameT }} x) where T : IFloatingPointIeee754<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.ReciprocalSqrtEstimate(x.{c})"; end }});

    // INumber<T>
    // public static {{ TypeNameT }} Clamp<T>({{ TypeNameT }} value, {{ TypeNameT }} min, {{ TypeNameT }} max) where T : INumber<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.Clamp(x.{c})"; end }});
    public static {{ TypeNameT }} CopySign<T>({{ TypeNameT }} value, {{ TypeNameT }} sign) where T : INumber<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.CopySign(value.{c}, sign.{c})"; end }});
    public static {{ TypeNameT }} CopySign<T>({{ TypeNameT }} value, T sign) where T : INumber<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.CopySign(value.{c}, sign)"; end }});
    public static {{ TypeNameT }} MaxNumber<T>({{ TypeNameT }} x, {{ TypeNameT }} y) where T : INumber<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.MaxNumber(x.{c}, y.{c})"; end }});
    public static {{ TypeNameT }} MinNumber<T>({{ TypeNameT }} x, {{ TypeNameT }} y) where T : INumber<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.MinNumber(x.{c}, y.{c})"; end }});

    // INumberBase<T>
    // public static {{ TypeNameT }} MaxMagnitude<T>({{ TypeNameT }} x, {{ TypeNameT }} y) where T : INumberBase<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.MaxMagnitude(x.{c}, y.{c})"; end }});
    // public static {{ TypeNameT }} MaxMagnitudeNumber<T>({{ TypeNameT }} x, {{ TypeNameT }} y) where T : INumberBase<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.MaxMagnitudeNumber(x.{c}, y.{c})"; end }});
    // public static {{ TypeNameT }} MinMagnitude<T>({{ TypeNameT }} x, {{ TypeNameT }} y) where T : INumberBase<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.MinMagnitude(x.{c}, y.{c})"; end }});
    // public static {{ TypeNameT }} MinMagnitudeNumber<T>({{ TypeNameT }} x, {{ TypeNameT }} y) where T : INumberBase<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.MinMagnitudeNumber(x.{c}, y.{c})"; end }});
    // (there's no reason you would want these.)



    // IFloatingPointIeee754<TSelf>
    public static {{ TypeName }}<int> ILogB<T>({{ TypeNameT }} x) where T : IFloatingPointIeee754<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.ILogB(x.{c})"; end }});
    public static {{ TypeNameT }} ScaleB<T>({{ TypeNameT }} x, {{ TypeName }}<int> n) where T : IFloatingPointIeee754<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.ScaleB(x.{c}, n.{c})"; end }});
    public static {{ TypeNameT }} ScaleB<T>({{ TypeNameT }} x, int n) where T : IFloatingPointIeee754<T> => new({{ wrap forEachDimension ', ' newline:false; $"T.ScaleB(x.{c}, n)"; end }});

    public static {{ TypeName }}<int> RoundToInt<T>({{ TypeNameT }} vector) where T : IFloatingPoint<T>
    {
        return new {{ TypeName }}<int>(
            {{ wrap forEachDimension ','; $"int.CreateSaturating(T.Round(vector.{c}))"; end }}
        );
    }

    public static {{ TypeName }}<int> FloorToInt<T>({{ TypeNameT }} vector) where T : IFloatingPoint<T>
    {
        return new {{ TypeName }}<int>(
            {{ wrap forEachDimension ','; $"int.CreateSaturating(T.Floor(vector.{c}))"; end }}
        );
    }

    public static {{ TypeName }}<int> CeilingToInt<T>({{ TypeNameT }} vector) where T : IFloatingPoint<T>
    {
        return new {{ TypeName }}<int>(
            {{ wrap forEachDimension ','; $"int.CreateSaturating(T.Ceiling(vector.{c}))"; end }}
        );
    }

    public static {{ TypeName }}<TInt> RoundToInt<T, TInt>({{ TypeNameT }} vector) where T : IFloatingPoint<T> where TInt : IBinaryInteger<TInt>
    {
        return new {{ TypeName }}<TInt>(
            {{ wrap forEachDimension ','; $"TInt.CreateSaturating(T.Round(vector.{c}))"; end }}
        );
    }

    public static {{ TypeName }}<TInt> FloorToInt<T, TInt>({{ TypeNameT }} vector) where T : IFloatingPoint<T> where TInt : IBinaryInteger<TInt>
    {
        return new {{ TypeName }}<TInt>(
            {{ wrap forEachDimension ','; $"TInt.CreateSaturating(T.Floor(vector.{c}))"; end }}
        );
    }

    public static {{ TypeName }}<TInt> CeilingToInt<T, TInt>({{ TypeNameT }} vector) where T : IFloatingPoint<T> where TInt : IBinaryInteger<TInt>
    {
        return new {{ TypeName }}<TInt>(
            {{ wrap forEachDimension ','; $"TInt.CreateSaturating(T.Ceiling(vector.{c}))"; end }}
        );
    }

    public static {{ TypeName }}<float> AsGeneric(this Vector{{vecN}} vector)
        => Unsafe.BitCast<Vector{{vecN}}, {{ TypeName }}<float>>(vector);

    public static Vector{{vecN}} AsNumerics(this {{ TypeName }}<float> vector)
        => Unsafe.BitCast<{{ TypeName }}<float>, Vector{{vecN}}>(vector);
}

{{ end }}