using System.Collections;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;
using System.Runtime.Serialization;
using System.Text.Unicode;

namespace GenericVector.Generated;

{{~ for vecN in min_dimensions..max_dimensions
    #for vecN in 3..3
-}}
{{~
    dimensionIndex = vecN - 1

    TypeName = $"Vector{vecN}D"
    TypeNameT = TypeName + '<T>'
    DocName = TypeName + '{T}'

    Components = ["X", "Y", "Z", "W"]
    Parameters = ["T x", "T y", "T z", "T w"]
    # ValueValue = [ "value.X", "value.Y", "value.Z", "value.W"]
    AmountName = "fuck"
    case vecN
        when 1
            AmountName = "one"
        when 2
            AmountName = "two"
        when 3
            AmountName = "three"
        when 4
            AmountName = "four"
    end

    max(x, y) = x > y ? x : y
    min(x, y) = x < y ? x : y

    func slice(value, indexStart = 0, indexEnd = null)
        len = object.size value

        indexEnd = indexEnd ?? len

        # If indexStart >= str.length, an empty string is returned.
        # If indexStart < 0, the index is counted from the end of the string. More formally, in this case, the substring starts at max(indexStart + str.length, 0).
        # If indexStart is omitted, undefined, or cannot be converted to a number, it's treated as 0.
        # If indexEnd is omitted, undefined, or cannot be converted to a number, or if indexEnd >= str.length, slice() extracts to the end of the string.
        # If indexEnd < 0, the index is counted from the end of the string. More formally, in this case, the substring ends at max(indexEnd + str.length, 0).
        # If indexEnd <= indexStart after normalizing negative values (i.e. indexEnd represents a character that's before indexStart), an empty string is returned.

        if indexStart < 0
            indexStart = max (indexStart + len) 0
        end

        if indexEnd < 0
            indexEnd = max (indexEnd + len) 0
        end

        case object.typeof value
            when 'string'
                if indexStart >= len || indexEnd <= indexStart
                    ret ''
                end

                ret value | string.slice indexStart (indexEnd - indexStart)
            when 'boolean'
                ret value
            when 'number'
                ret value
            when 'array'
                if indexStart >= len || indexEnd <= indexStart
                    ret []
                end

                ret value | array.limit indexEnd | array.offset indexStart
            when 'iterator'
                ret value
            when 'object'
                ret value
            else
                ret value
        end
    end

    func valueValue(prefix, downcase = false)
        arr = []
        for x in 0..<max_dimensions
            arr = arr | array.add (prefix + (downcase ? (Components[x] | string.downcase) : Components[x]))
        end
        ret arr
    end

    func humanizeAnd(items)
        if items.size == 1
            ret items[0]
        end

        itemsRest = items | array.limit (items.size - 1)
        itemLast = items[items.size - 1]
        ret $"{itemsRest | array.join ', '} and {itemLast}"
    end

    func operation(x, left, op, right, connector)
        s = $"({left}.{Components[x]} {op} {right}.{Components[x]})"
        if x < vecN - 1
            s += connector
        end
        ret s
    end

    func complexOperation(x, left1, left2, op, right1, right2, connector)
        s = $"({left1}{Components[x]}{left2} {op} {right1}{Components[x]}{right2})"
        if x < vecN - 1
            s += connector
        end
        ret s
    end

    func repeatCall(method, parameter, x = null, sep = ', ', startOffset = 0)
        list = []
        for x in startOffset..<(x ?? vecN)
            list = list | array.add $"{method}({parameter}.{Components[x]})"
        end
        ret list | array.join sep
    end

    func repeatCall2(method, parameter, parameter2, x = null, sep = ', ', startOffset = 0)
        list = []
        for x in 0..<(x ?? vecN)
            list = list | array.add $"{method}({parameter}.{Components[x]}, {parameter2}.{Components[x]})"
        end
        ret list | array.join sep
    end
~}}

// {{ TypeNameT }}
[StructLayout(LayoutKind.Sequential), DataContract, Serializable]
public readonly partial struct {{TypeNameT}} : IVector<{{TypeNameT}}, T>, IVectorAlso<{{TypeNameT}}, T>, IEquatable<Vector{{vecN}}>, ISpanFormattable
    where T : INumberBase<T>
{
    {{~ for x in 0..dimensionIndex ~}}
    /// <summary>The {{ Components[x] }} component of the vector.</summary>
    [DataMember]
    public readonly T {{ Components[x] }};
    {{~ end ~}}

    internal const int Count = {{ vecN }};

    /// <summary>Creates a new <see cref="{{ DocName }}" /> object whose {{ AmountName }} elements have the same value.</summary>
    /// <param name="value">The value to assign to all {{ AmountName }} elements.</param>
    public {{ TypeName }}(T value) : this({{ ['value'] * vecN | array.join ', '}})
    {
    }

    {{~ for smallerVecN in min_dimensions..<vecN ~}}
    /// <summary>Creates a new <see cref="{{ DocName }}" /> object from the specified <see cref="Vector{{vecN}}D{T}" /> object {{ Components | array.offset dimensions2 | array.join ' and a ' }} component.</summary>
    /// <param name="value">The vector to use for the {{ Components | array.limit dimensions2 | humanizeAnd }} components.</param>
        {{~ for x in Components | slice smallerVecN vecN ~}}
    /// <param name="{{ x | string.downcase }}">The {{ x }} component.</param>
        {{~ end ~}}
    public {{ TypeName }}(Vector{{smallerVecN}}D<T> value, {{ Parameters | array.limit vecN  | array.offset dimensions2 | array.join ', ' }}) : this(
        {{- valueValue 'value.' | slice 0 smallerVecN | array.concat (Components | slice smallerVecN vecN | array.each @string.downcase) | array.join ', ' -}}
    )
    {
    }
    {{~ end ~}}

    /// <summary>Creates a vector whose elements have the specified values.</summary>
    {{~ for x in Components | array.limit vecN ~}}
    /// <param name="{{ x | string.downcase }}">The value to assign to the <see cref="{{ x }}" /> field.</param>
    {{~ end ~}}
    public {{ TypeName }}({{ Parameters | array.limit vecN | array.join ', ' }})
    {
        Unsafe.SkipInit(out this);

        {{~ for x in Components | array.limit vecN ~}}
        {{ x }} = {{ x | string.downcase}};
        {{~ end ~}}
    }

    /// <summary>Constructs a vector from the given <see cref="ReadOnlySpan{T}" />. The span must contain at least 4 elements.</summary>
    /// <param name="values">The span of elements to assign to the vector.</param>
    public {{ TypeName }}(ReadOnlySpan<T> values)
    {
        Unsafe.SkipInit(out this);

        ArgumentOutOfRangeException.ThrowIfLessThan(values.Length, Count, nameof(values));

        this = Unsafe.ReadUnaligned<{{ TypeNameT }}>(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(values)));
    }

    /// <summary>Gets a vector whose 4 elements are equal to zero.</summary>
    /// <value>A vector whose {{ AmountName }} elements are equal to zero (that is, it returns the vector <c>({{ ['0'] * vecN | array.join ',' }})</c>.</value>
    public static {{ TypeNameT }} Zero => new(T.Zero);

    /// <summary>Gets a vector whose 4 elements are equal to one.</summary>
    /// <value>Returns <see cref="{{ DocName }}" />.</value>
    /// <remarks>A vector whose {{ AmountName }} elements are equal to one (that is, it returns the vector <c>({{ ['1'] * vecN | array.join ',' }})</c>.</remarks>
    public static {{ TypeNameT }} One => new(T.One);

    {{~ for x in 0..dimensionIndex ~}}
    {{
        v = ['0'] * vecN
        v[x] = '1';
        v = v | array.join ','

        v2 = ['T.Zero'] * vecN
        v2[x] = 'T.One';
        v2 = v2 | array.join ', '
    -}}
    /// <summary>Gets the vector ({{v}})).</summary>
    /// <value>The vector <c>({{v}})</c>.</value>
    public static {{ TypeNameT }} Unit{{ Components[x] }} => new({{v2}});
    {{~ end ~}}

    public ReadOnlySpan<T> Components
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => MemoryMarshal.CreateReadOnlySpan<T>(ref Unsafe.AsRef(in X), Count);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static {{ TypeNameT }} IVector<{{ TypeNameT }}, T>.CreateFromRepeatingComponent(T scalar) => new(scalar);

    /// <summary>Gets or sets the element at the specified index.</summary>
    /// <param name="index">The index of the element to get or set.</param>
    /// <returns>The the element at <paramref name="index" />.</returns>
    /// <exception cref="ArgumentOutOfRangeException"><paramref name="index" /> was less than zero or greater than the number of elements.</exception>
    public T this[int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => Components[index];
    }

    #region Operators
    /// <summary>Adds two vectors together.</summary>
    /// <param name="left">The first vector to add.</param>
    /// <param name="right">The second vector to add.</param>
    /// <returns>The summed vector.</returns>
    /// <remarks>The <see cref="op_Addition" /> method defines the addition operation for <see cref="{{ DocName }}" /> objects.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} operator +({{ TypeNameT }} left, {{ TypeNameT }} right)
    {
        return new {{ TypeNameT }}(
        {{~ for x in 0..dimensionIndex ~}}
            {{ operation x 'left' '+' 'right' ',' }}
        {{~ end ~}}
        );
    }

    /// <summary>Subtracts the second vector from the first.</summary>
    /// <param name="left">The first vector.</param>
    /// <param name="right">The second vector.</param>
    /// <returns>The vector that results from subtracting <paramref name="right" /> from <paramref name="left" />.</returns>
    /// <remarks>The <see cref="op_Subtraction" /> method defines the subtraction operation for <see cref="{{ DocName }}" /> objects.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} operator -({{ TypeNameT }} left, {{ TypeNameT }} right)
    {
        return new {{ TypeNameT }}(
        {{~ for x in 0..dimensionIndex ~}}
            {{ operation x 'left' '-' 'right' ',' }}
        {{~ end ~}}
        );
    }

    /// <summary>Negates the specified vector.</summary>
    /// <param name="value">The vector to negate.</param>
    /// <returns>The negated vector.</returns>
    /// <remarks>The <see cref="op_UnaryNegation" /> method defines the unary negation operation for <see cref="{{ DocName }}" /> objects.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} operator -({{ TypeNameT }} value)
    {
        return Zero - value;
    }

    /// <summary>Returns a new vector whose values are the product of each pair of elements in two specified vectors.</summary>
    /// <param name="left">The first vector.</param>
    /// <param name="right">The second vector.</param>
    /// <returns>The element-wise product vector.</returns>
    /// <remarks>The <see cref="{{ DocName }}.op_Multiply" /> method defines the multiplication operation for <see cref="{{ DocName }}" /> objects.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} operator *({{ TypeNameT }} left, {{ TypeNameT }} right)
    {
        return new {{ TypeNameT }}(
        {{~ for x in 0..dimensionIndex ~}}
            {{ operation x 'left' '*' 'right' ',' }}
        {{~ end ~}}
        );
    }

    /// <summary>Multiplies the specified vector by the specified scalar value.</summary>
    /// <param name="left">The vector.</param>
    /// <param name="right">The scalar value.</param>
    /// <returns>The scaled vector.</returns>
    /// <remarks>The <see cref="{{ DocName }}.op_Multiply" /> method defines the multiplication operation for <see cref="{{ DocName }}" /> objects.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} operator *({{ TypeNameT }} left, T right)
    {
        return left * new {{ TypeNameT }}(right);
    }

    /// <summary>Multiplies the scalar value by the specified vector.</summary>
    /// <param name="left">The vector.</param>
    /// <param name="right">The scalar value.</param>
    /// <returns>The scaled vector.</returns>
    /// <remarks>The <see cref="{{ DocName }}.op_Multiply" /> method defines the multiplication operation for <see cref="{{ DocName }}" /> objects.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} operator *(T left, {{ TypeNameT }} right)
    {
        return right * left;
    }

    /// <summary>Divides the first vector by the second.</summary>
    /// <param name="left">The first vector.</param>
    /// <param name="right">The second vector.</param>
    /// <returns>The vector that results from dividing <paramref name="left" /> by <paramref name="right" />.</returns>
    /// <remarks>The <see cref="{{ DocName }}.op_Division" /> method defines the division operation for <see cref="{{ DocName }}" /> objects.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} operator /({{ TypeNameT }} left, {{ TypeNameT }} right)
    {
        return new {{ TypeNameT }}(
        {{~ for x in 0..dimensionIndex ~}}
            {{ operation x 'left' '/' 'right' ',' }}
        {{~ end ~}}
        );
    }

    /// <summary>Divides the specified vector by a specified scalar value.</summary>
    /// <param name="value1">The vector.</param>
    /// <param name="value2">The scalar value.</param>
    /// <returns>The result of the division.</returns>
    /// <remarks>The <see cref="{{ DocName }}.op_Division" /> method defines the division operation for <see cref="{{ DocName }}" /> objects.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} operator /({{ TypeNameT }} value1, T value2)
    {
        return value1 / new {{ TypeNameT }}(value2);
    }

    /// <summary>Returns a value that indicates whether each pair of elements in two specified vectors is equal.</summary>
    /// <param name="left">The first vector to compare.</param>
    /// <param name="right">The second vector to compare.</param>
    /// <returns><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <see langword="false" />.</returns>
    /// <remarks>Two <see cref="{{ DocName }}" /> objects are equal if each element in <paramref name="left" /> is equal to the corresponding element in <paramref name="right" />.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator ==({{ TypeNameT }} left, {{ TypeNameT }} right)
    {
        return {{ for x in 0..dimensionIndex ~}} {{ operation x 'left' '==' 'right' ' && ' }} {{~ end -}};
    }

    /// <summary>Returns a value that indicates whether two specified vectors are not equal.</summary>
    /// <param name="left">The first vector to compare.</param>
    /// <param name="right">The second vector to compare.</param>
    /// <returns><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator !=({{ TypeNameT }} left, {{ TypeNameT }} right)
    {
        return !(left == right);
    }
    #endregion

    #region CopyTo
    /// <summary>Copies the elements of the vector to a specified array.</summary>
    /// <param name="array">The destination array.</param>
    /// <remarks><paramref name="array" /> must have at least {{ AmountName }} elements. The method copies the vector's elements starting at index 0.</remarks>
    /// <exception cref="NullReferenceException"><paramref name="array" /> is <see langword="null" />.</exception>
    /// <exception cref="ArgumentException">The number of elements in the current instance is greater than in the array.</exception>
    /// <exception cref="RankException"><paramref name="array" /> is multidimensional.</exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void CopyTo(T[] array)
    {
        // We explicitly don't check for `null` because historically this has thrown `NullReferenceException` for perf reasons

        ArgumentOutOfRangeException.ThrowIfLessThan(array.Length, Count, nameof(array));

        Unsafe.WriteUnaligned(ref Unsafe.As<T, byte>(ref array[0]), this);
    }

    /// <summary>Copies the elements of the vector to a specified array starting at a specified index position.</summary>
    /// <param name="array">The destination array.</param>
    /// <param name="index">The index at which to copy the first element of the vector.</param>
    /// <remarks><paramref name="array" /> must have a sufficient number of elements to accommodate the {{ AmountName }} vector elements. In other words, elements <paramref name="index" /> through <paramref name="index" /> + {{vecN}} must already exist in <paramref name="array" />.</remarks>
    /// <exception cref="NullReferenceException"><paramref name="array" /> is <see langword="null" />.</exception>
    /// <exception cref="ArgumentException">The number of elements in the current instance is greater than in the array.</exception>
    /// <exception cref="ArgumentOutOfRangeException"><paramref name="index" /> is less than zero.
    /// -or-
    /// <paramref name="index" /> is greater than or equal to the array length.</exception>
    /// <exception cref="RankException"><paramref name="array" /> is multidimensional.</exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void CopyTo(T[] array, int index)
    {
        // We explicitly don't check for `null` because historically this has thrown `NullReferenceException` for perf reasons

        ArgumentOutOfRangeException.ThrowIfGreaterThanOrEqual((uint)index, (uint)array.Length);
        ArgumentOutOfRangeException.ThrowIfLessThan((array.Length - index), Count);

        Unsafe.WriteUnaligned(ref Unsafe.As<T, byte>(ref array[index]), this);
    }

    /// <summary>Copies the vector to the given <see cref="Span{T}" />. The length of the destination span must be at least 4.</summary>
    /// <param name="destination">The destination span which the values are copied into.</param>
    /// <exception cref="ArgumentException">If number of elements in source vector is greater than those available in destination span.</exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void CopyTo(Span<T> destination)
    {
        ArgumentOutOfRangeException.ThrowIfLessThan(destination.Length, Count, nameof(destination));

        Unsafe.WriteUnaligned(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(destination)), this);
    }

    /// <summary>Attempts to copy the vector to the given <see cref="Span{Single}" />. The length of the destination span must be at least 4.</summary>
    /// <param name="destination">The destination span which the values are copied into.</param>
    /// <returns><see langword="true" /> if the source vector was successfully copied to <paramref name="destination" />. <see langword="false" /> if <paramref name="destination" /> is not large enough to hold the source vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryCopyTo(Span<T> destination)
    {
        if (destination.Length < Count)
        {
            return false;
        }

        Unsafe.WriteUnaligned(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(destination)), this);
        return true;
    }
    #endregion

    #region Equality
    /// <summary>Returns a value that indicates whether this instance and another vector are equal.</summary>
    /// <param name="other">The other vector.</param>
    /// <returns><see langword="true" /> if the two vectors are equal; otherwise, <see langword="false" />.</returns>
    /// <remarks>Two vectors are equal if their <see cref="X" />, <see cref="Y" />, <see cref="Z" />, and <see cref="W" /> elements are equal.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool Equals({{ TypeNameT }} other)
    {
        return SpeedHelpers.FastEqualsUpTo4<{{ TypeNameT }}, T>(this, other);
    }

    /// <summary>Returns a value that indicates whether this instance and a specified object are equal.</summary>
    /// <param name="obj">The object to compare with the current instance.</param>
    /// <returns><see langword="true" /> if the current instance and <paramref name="obj" /> are equal; otherwise, <see langword="false" />. If <paramref name="obj" /> is <see langword="null" />, the method returns <see langword="false" />.</returns>
    /// <remarks>The current instance and <paramref name="obj" /> are equal if <paramref name="obj" /> is a <see cref="{{ DocName }}" /> object and their corresponding elements are equal.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public override bool Equals([NotNullWhen(true)] object? obj)
    {
        return (obj is {{ TypeNameT }} other) && Equals(other);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool Equals(Vector{{ vecN }} other)
    {
        if (typeof(T) == typeof(float) && Vector128.IsHardwareAccelerated)
        {
            return Unsafe.BitCast<{{ TypeNameT }}, Vector{{ vecN }}>(this).AsVector128().Equals(other.AsVector128());
        }

        return {{- for x in 0..dimensionIndex }}
            float.CreateTruncating({{Components[x]}}).Equals(other.{{Components[x]}}) {{- if x < dimensionIndex }} && {{ end }}
        {{~ end ~}};
    }

    /// <summary>Returns the hash code for this instance.</summary>
    /// <returns>The hash code.</returns>
    public override int GetHashCode()
    {
        return HashCode.Combine({{ Components | array.limit vecN | array.join ', ' }});
    }
    #endregion

    #region Format
    /// <summary>Returns the string representation of the current instance using default formatting.</summary>
    /// <returns>The string representation of the current instance.</returns>
    /// <remarks>This method returns a string in which each element of the vector is formatted using the "G" (general) format string and the formatting conventions of the current thread culture. The "&lt;" and "&gt;" characters are used to begin and end the string, and the current culture's <see cref="NumberFormatInfo.NumberGroupSeparator" /> property followed by a space is used to separate each element.</remarks>
    public override string ToString()
    {
        return ToString("G", CultureInfo.CurrentCulture);
    }

    /// <summary>Returns the string representation of the current instance using the specified format string to format individual elements.</summary>
    /// <param name="format">A standard or custom numeric format string that defines the format of individual elements.</param>
    /// <returns>The string representation of the current instance.</returns>
    /// <remarks>This method returns a string in which each element of the vector is formatted using <paramref name="format" /> and the current culture's formatting conventions. The "&lt;" and "&gt;" characters are used to begin and end the string, and the current culture's <see cref="NumberFormatInfo.NumberGroupSeparator" /> property followed by a space is used to separate each element.</remarks>
    /// <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">Standard Numeric Format Strings</related>
    /// <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">Custom Numeric Format Strings</related>
    public string ToString([StringSyntax(StringSyntaxAttribute.NumericFormat)] string? format)
    {
        return ToString(format, CultureInfo.CurrentCulture);
    }

    /// <summary>Returns the string representation of the current instance using the specified format string to format individual elements and the specified format provider to define culture-specific formatting.</summary>
    /// <param name="format">A standard or custom numeric format string that defines the format of individual elements.</param>
    /// <param name="formatProvider">A format provider that supplies culture-specific formatting information.</param>
    /// <returns>The string representation of the current instance.</returns>
    /// <remarks>This method returns a string in which each element of the vector is formatted using <paramref name="format" /> and <paramref name="formatProvider" />. The "&lt;" and "&gt;" characters are used to begin and end the string, and the format provider's <see cref="NumberFormatInfo.NumberGroupSeparator" /> property followed by a space is used to separate each element.</remarks>
    /// <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">Standard Numeric Format Strings</related>
    /// <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">Custom Numeric Format Strings</related>
    public string ToString([StringSyntax(StringSyntaxAttribute.NumericFormat)] string? format, IFormatProvider? formatProvider)
    {
        var separator = NumberFormatInfo.GetInstance(formatProvider).NumberGroupSeparator;

        Span<char> initialBuffer = stackalloc char[Math.Min((2 + (Count - 1) + (separator.Length * (Count - 1)) + (Count * 2)), 256)];

        // We can't use an interpolated string here because it won't allow us to pass `format`
        var handler = new DefaultInterpolatedStringHandler(
            4 + (separator.Length * 2),
            Count,
            formatProvider,
            initialBuffer
        );

        handler.AppendLiteral("<");
        {{~ for x in 0..dimensionIndex ~}}
        handler.AppendFormatted({{ Components[x] }}, format);
            {{~ if x < dimensionIndex ~}}
        handler.AppendLiteral(separator);
        handler.AppendLiteral(" ");
            {{~ end ~}}
        {{~ end ~}}
        handler.AppendLiteral(">");

        return handler.ToStringAndClear();
    }

    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        // Possible fast path for failure case:
        // if (destination.Length < 4) return false;

        var separator = NumberFormatInfo.GetInstance(provider).NumberGroupSeparator;

        // We can't use an interpolated string here because it won't allow us to pass `format`
        var handler = new MemoryExtensions.TryWriteInterpolatedStringHandler(
            4 + (separator.Length * 2),
            Count,
            destination,
            provider,
            out var shouldAppend
        );
        if (!shouldAppend)
        {
            charsWritten = 0;
            return false;
        }

        // Annoyingly we need to turn the span into a string for the string handler
        string? formatString = format.Length > 0 ? new string(format) : null;

        _ =
            handler.AppendLiteral("<") &&
            {{~ for x in 0..dimensionIndex ~}}
            handler.AppendFormatted({{ Components[x] }}, formatString) &&
                {{~ if x < dimensionIndex ~}}
            handler.AppendLiteral(separator) &&
            handler.AppendLiteral(" ") &&
                {{~ end ~}}
            {{~ end ~}}
            handler.AppendLiteral(">");

        return destination.TryWrite(ref handler, out charsWritten);
    }
    #endregion

    #region Casts
    public {{ TypeName }}<TOther> As<TOther>() where TOther : INumberBase<TOther>
    {
        if (SpeedHelpers.TryFastConvert<{{ TypeNameT }}, T, {{ TypeName }}<TOther>, TOther>(this, out var result))
        {
            return result;
        }

        return new {{ TypeName }}<TOther>(
            {{- for x in 0..dimensionIndex }}
            TOther.CreateTruncating({{Components[x]}})
            {{- if dim < dimensionIndex }},{{ end -}}
            {{~ end }}
        );
    }

    private {{ TypeName }}<TOther> AsChecked<TOther>() where TOther : INumberBase<TOther>
    {
        return new {{ TypeName }}<TOther>(
            {{- for x in 0..dimensionIndex }}
            TOther.CreateChecked({{Components[x]}})
            {{- if x < dimensionIndex }},{{ end -}}
            {{~ end }}
        );
    }
    public static explicit operator {{ TypeName }}<byte>({{ TypeNameT }} self) => self.As<byte>();
    public static explicit operator {{ TypeName }}<sbyte>({{ TypeNameT }} self) => self.As<sbyte>();
    public static explicit operator {{ TypeName }}<short>({{ TypeNameT }} self) => self.As<short>();
    public static explicit operator {{ TypeName }}<ushort>({{ TypeNameT }} self) => self.As<ushort>();
    public static explicit operator {{ TypeName }}<int>({{ TypeNameT }} self) => self.As<int>();
    public static explicit operator {{ TypeName }}<uint>({{ TypeNameT }} self) => self.As<uint>();
    public static explicit operator {{ TypeName }}<long>({{ TypeNameT }} self) => self.As<long>();
    public static explicit operator {{ TypeName }}<ulong>({{ TypeNameT }} self) => self.As<ulong>();
    public static explicit operator {{ TypeName }}<Int128>({{ TypeNameT }} self) => self.As<Int128>();
    public static explicit operator {{ TypeName }}<UInt128>({{ TypeNameT }} self) => self.As<UInt128>();
    public static explicit operator {{ TypeName }}<Half>({{ TypeNameT }} self) => self.As<Half>();
    public static explicit operator {{ TypeName }}<float>({{ TypeNameT }} self) => self.As<float>();
    public static explicit operator {{ TypeName }}<double>({{ TypeNameT }} self) => self.As<double>();
    public static explicit operator {{ TypeName }}<decimal>({{ TypeNameT }} self) => self.As<decimal>();
    public static explicit operator {{ TypeName }}<Complex>({{ TypeNameT }} self) => self.As<Complex>();
    public static explicit operator {{ TypeName }}<BigInteger>({{ TypeNameT }} self) => self.As<BigInteger>();

    public static explicit operator checked {{ TypeName }}<byte>({{ TypeNameT }} self) => self.AsChecked<byte>();
    public static explicit operator checked {{ TypeName }}<sbyte>({{ TypeNameT }} self) => self.AsChecked<sbyte>();
    public static explicit operator checked {{ TypeName }}<short>({{ TypeNameT }} self) => self.AsChecked<short>();
    public static explicit operator checked {{ TypeName }}<ushort>({{ TypeNameT }} self) => self.AsChecked<ushort>();
    public static explicit operator checked {{ TypeName }}<int>({{ TypeNameT }} self) => self.AsChecked<int>();
    public static explicit operator checked {{ TypeName }}<uint>({{ TypeNameT }} self) => self.AsChecked<uint>();
    public static explicit operator checked {{ TypeName }}<long>({{ TypeNameT }} self) => self.AsChecked<long>();
    public static explicit operator checked {{ TypeName }}<ulong>({{ TypeNameT }} self) => self.AsChecked<ulong>();
    public static explicit operator checked {{ TypeName }}<Int128>({{ TypeNameT }} self) => self.AsChecked<Int128>();
    public static explicit operator checked {{ TypeName }}<UInt128>({{ TypeNameT }} self) => self.AsChecked<UInt128>();
    public static explicit operator checked {{ TypeName }}<Half>({{ TypeNameT }} self) => self.AsChecked<Half>();
    public static explicit operator checked {{ TypeName }}<float>({{ TypeNameT }} self) => self.AsChecked<float>();
    public static explicit operator checked {{ TypeName }}<double>({{ TypeNameT }} self) => self.AsChecked<double>();
    public static explicit operator checked {{ TypeName }}<decimal>({{ TypeNameT }} self) => self.AsChecked<decimal>();
    public static explicit operator checked {{ TypeName }}<Complex>({{ TypeNameT }} self) => self.AsChecked<Complex>();
    public static explicit operator checked {{ TypeName }}<BigInteger>({{ TypeNameT }} self) => self.AsChecked<BigInteger>();

    // Cast from System.Numerics.Vector{{vecN}}
    public static explicit operator {{ TypeNameT }}(Vector{{ vecN }} self) => new({{repeatCall 'T.CreateTruncating' 'self' }});
    public static explicit operator checked {{ TypeNameT }}(Vector{{ vecN }} self) => new({{repeatCall 'T.CreateChecked' 'self' }});

    // Cast to System.Numerics.Vector{{vecN}}
    public static explicit operator Vector{{ vecN }}({{ TypeNameT }} self) => new({{repeatCall 'float.CreateTruncating' 'self' }});
    public static explicit operator checked Vector{{ vecN }}({{ TypeNameT }} self) => new({{repeatCall 'float.CreateChecked' 'self' }});

    // Downcast
    {{~ for x in min_dimensions..dimensionIndex ~}}
    public static explicit operator Vector{{x}}D<T>({{ TypeNameT }} self) => new(
        {{- valueValue 'self.' | array.limit x | array.join ', ' -}}
    );
    {{~ end ~}}

    // Upcast
    {{~ if vecN < max_dimensions ~}}
    {{~ for x in (vecN + 1)..max_dimensions ~}}
    public static explicit operator Vector{{x}}D<T>({{ TypeNameT }} self) => new(self, {{ ["T.Zero"] * (x - vecN) | array.join ', ' }});
    {{~ end ~}}
    {{~ end ~}}

    // Upcast from System.Numerics.Vector < {{vecN}}
    {{~ for x in min_dimensions..dimensionIndex ~}}
    public static explicit operator {{ TypeNameT }}(Vector{{x}} self) => new({{repeatCall 'T.CreateTruncating' 'self' x}}, {{ ["T.Zero"] * (vecN - x) | array.join ', ' }});
    public static explicit operator checked {{ TypeNameT }}(Vector{{x}} self) => new({{repeatCall 'T.CreateChecked' 'self' x}}, {{ ["T.Zero"] * (vecN - x) | array.join ', ' }});
    {{~ end ~}}

    // Downcast from System.Numerics.Vector > {{vecN}}
    {{~ for x in (vecN + 1)..<max_dimensions ~}}
    public static explicit operator {{ TypeNameT }}(Vector{{x}} self) => new({{repeatCall 'T.CreateTruncating' 'self' }});
    public static explicit operator checked {{ TypeNameT }}(Vector{{x}} self) => new({{repeatCall 'T.CreateChecked' 'self' }});
    {{~ end ~}}

    public static implicit operator {{ TypeNameT }}(({{ valueValue 'T ' | array.limit vecN | array.join ', ' }}) components)
        => new({{ valueValue 'components.' | array.limit vecN | array.join ', ' }});

    #endregion

    public void Deconstruct({{ valueValue 'out T ' true | array.limit vecN | array.join ', ' }})
    {
    {{~ for x in 0..dimensionIndex ~}}
        {{ Components[x] | string.downcase }} = {{ Components[x] }};
    {{~ end ~}}
    }
}

file interface IVec{{vecN}}
{
    // Returns null if incompatible. Throws OverflowException if overflowing
    {{TypeNameT}}? GetChecked<T>() where T : INumberBase<T>;
    {{TypeNameT}}? GetSaturating<T>() where T : INumberBase<T>;
    {{TypeNameT}}? GetTruncating<T>() where T : INumberBase<T>;
}

// {{ TypeNameT }}.INumber
public readonly partial struct {{TypeNameT}} :
    IDivisionOperators<{{TypeNameT}}, T, {{TypeNameT}}>,
    IMultiplyOperators<{{TypeNameT}}, T, {{TypeNameT}}>,
    INumberBase<{{TypeNameT}}>,
    IVec{{vecN}}
{
    /// <summary>Returns a vector whose elements are the absolute values of each of the specified vector's elements.</summary>
    /// <param name="value">A vector.</param>
    /// <returns>The absolute value vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static {{ TypeNameT }} INumberBase<{{ TypeNameT }}>.Abs({{ TypeNameT }} value) => {{ TypeName }}.Abs(value);

    static {{TypeNameT}} IParsable<{{TypeNameT}}>.Parse(string s, IFormatProvider? provider)
        => Parse(s.AsSpan(), NumberStyles.None, provider);

    static {{TypeNameT}} ISpanParsable<{{TypeNameT}}>.Parse(ReadOnlySpan<char> s, IFormatProvider? provider)
        => Parse(s, NumberStyles.None, provider);

    public static {{TypeNameT}} Parse(string s, NumberStyles style = default, IFormatProvider? provider = null)
        => Parse(s.AsSpan(), style, provider);

    public static {{TypeNameT}} Parse(ReadOnlySpan<char> s, NumberStyles style = NumberStyles.None, IFormatProvider? provider = null)
        => TryParse(s, style, provider, out var result) ? result : throw new ArgumentException($"Failed to parse {nameof(Vector{{vecN}})}<{typeof(T)}>");

    public static bool TryParse(string? s, IFormatProvider? provider, out {{TypeNameT}} result)
        => TryParse(s.AsSpan(), NumberStyles.None, provider, out result);

    public static bool TryParse(string? s, NumberStyles style, IFormatProvider? provider, out {{TypeNameT}} result)
        => TryParse(s.AsSpan(), style, provider, out result);

    public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out {{TypeNameT}} result)
        => TryParse(s, NumberStyles.None, provider, out result);

    public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider, out {{TypeNameT}} result)
    {
        result = default;

        if (s[0] != '<') return false;
        if (s[^1] != '>') return false;

        var separator = NumberFormatInfo.GetInstance(provider).NumberGroupSeparator;

        s = s[1..^1];

        T? {{ Components | array.limit vecN | array.join ', ' | string.downcase }};

        {{~ for x in 0..<(vecN - 1) ~}}
        {
            if (s.Length == 0) return false;

            var nextNumber = s.IndexOf(separator);
            if (nextNumber == -1)
            {
                return false;
            }

            if (!T.TryParse(s[..nextNumber], style, provider, out {{ Components[x] | string.downcase }})) return false;

            s = s[(nextNumber + separator.Length)..];
        }
        {{~ end ~}}

        {
            if (s.Length == 0) return false;

            if (!T.TryParse(s, style,provider, out {{ Components[vecN-1] | string.downcase }})) return false;
        }

        result = new {{TypeNameT}}({{ Components | array.limit vecN | array.join ', ' | string.downcase }});
        return true;
    }

    static {{TypeNameT}} IAdditiveIdentity<{{TypeNameT}}, {{TypeNameT}}>.AdditiveIdentity => Zero;
    static {{TypeNameT}} IMultiplicativeIdentity<{{TypeNameT}}, {{TypeNameT}}>.MultiplicativeIdentity => One;

    static {{TypeNameT}} IDecrementOperators<{{TypeNameT}}>.operator --({{TypeNameT}} value) => value - One;
    static {{TypeNameT}} IIncrementOperators<{{TypeNameT}}>.operator ++({{TypeNameT}} value) => value + One;

    static {{TypeNameT}} IUnaryPlusOperators<{{TypeNameT}}, {{TypeNameT}}>.operator +({{TypeNameT}} value) => value;

    static bool INumberBase<{{TypeNameT}}>.IsCanonical({{TypeNameT}} value) => {{ repeatCall 'T.IsCanonical' 'value' sep:' && ' }};

    static bool INumberBase<{{TypeNameT}}>.IsComplexNumber({{TypeNameT}} value) => {{ repeatCall 'T.IsComplexNumber' 'value' sep:' || ' }};

    static bool INumberBase<{{TypeNameT}}>.IsEvenInteger({{TypeNameT}} value) => {{ repeatCall 'T.IsEvenInteger' 'value' sep:' && ' }};

    static bool INumberBase<{{TypeNameT}}>.IsFinite({{TypeNameT}} value) => {{ repeatCall 'T.IsFinite' 'value' sep:' && ' }};

    static bool INumberBase<{{TypeNameT}}>.IsImaginaryNumber({{TypeNameT}} value) => {{ repeatCall 'T.IsImaginaryNumber' 'value' sep:' || ' }};

    static bool INumberBase<{{TypeNameT}}>.IsInfinity({{TypeNameT}} value) => {{ repeatCall 'T.IsInfinity' 'value' sep:' && ' }};

    static bool INumberBase<{{TypeNameT}}>.IsInteger({{TypeNameT}} value) => {{ repeatCall 'T.IsInteger' 'value' sep:' && ' }};

    static bool INumberBase<{{TypeNameT}}>.IsNaN({{TypeNameT}} value) => {{ repeatCall 'T.IsNaN' 'value' sep:' || ' }};

    static bool INumberBase<{{TypeNameT}}>.IsNegative({{TypeNameT}} value) => {{ repeatCall 'T.IsNegative' 'value' sep:' && ' }};

    static bool INumberBase<{{TypeNameT}}>.IsNegativeInfinity({{TypeNameT}} value) => {{ repeatCall 'T.IsNegativeInfinity' 'value' sep:' && ' }};

    static bool INumberBase<{{TypeNameT}}>.IsNormal({{TypeNameT}} value) => {{ repeatCall 'T.IsNormal' 'value' sep:' && ' }};

    static bool INumberBase<{{TypeNameT}}>.IsOddInteger({{TypeNameT}} value) => {{ repeatCall 'T.IsOddInteger' 'value' sep:' && ' }};

    static bool INumberBase<{{TypeNameT}}>.IsPositive({{TypeNameT}} value) => {{ repeatCall 'T.IsPositive' 'value' sep:' && ' }};

    static bool INumberBase<{{TypeNameT}}>.IsPositiveInfinity({{TypeNameT}} value) => {{ repeatCall 'T.IsPositiveInfinity' 'value' sep:' && ' }};

    static bool INumberBase<{{TypeNameT}}>.IsRealNumber({{TypeNameT}} value) => {{ repeatCall 'T.IsRealNumber' 'value' sep:' && ' }};

    static bool INumberBase<{{TypeNameT}}>.IsSubnormal({{TypeNameT}} value) => {{ repeatCall 'T.IsSubnormal' 'value' sep:' && ' }};

    static bool INumberBase<{{TypeNameT}}>.IsZero({{TypeNameT}} value) => {{ repeatCall 'T.IsZero' 'value' sep:' && ' }};

    static {{TypeNameT}} INumberBase<{{TypeNameT}}>.MaxMagnitude({{TypeNameT}} x, {{TypeNameT}} y) => new({{ repeatCall2 'T.MaxMagnitude' 'x' 'y' }});

    static {{TypeNameT}} INumberBase<{{TypeNameT}}>.MaxMagnitudeNumber({{TypeNameT}} x, {{TypeNameT}} y) => new({{ repeatCall2 'T.MaxMagnitudeNumber' 'x' 'y' }});

    static {{TypeNameT}} INumberBase<{{TypeNameT}}>.MinMagnitude({{TypeNameT}} x, {{TypeNameT}} y) => new({{ repeatCall2 'T.MinMagnitude' 'x' 'y' }});

    static {{TypeNameT}} INumberBase<{{TypeNameT}}>.MinMagnitudeNumber({{TypeNameT}} x, {{TypeNameT}} y) => new({{ repeatCall2 'T.MinMagnitudeNumber' 'x' 'y' }});

    public static bool TryConvertFromChecked<TOther>(TOther value, out {{TypeNameT}} result) where TOther : INumberBase<TOther>
    {
        if (value is {{TypeNameT}} v)
        {
            result = v;
            return true;
        }

        if (value is IVec{{vecN}} IVec{{vecN}} && IVec{{vecN}}.GetChecked<T>() is {} r)
        {
            result = r;
            return true;
        }

        result = default;
        return false;
    }

    public static bool TryConvertFromSaturating<TOther>(TOther value, out {{TypeNameT}} result) where TOther : INumberBase<TOther>
    {
        if (value is {{TypeNameT}} v)
        {
            result = v;
            return true;
        }

        if (value is IVec{{vecN}} IVec{{vecN}} && IVec{{vecN}}.GetSaturating<T>() is {} r)
        {
            result = r;
            return true;
        }

        result = default;
        return false;
    }

    public static bool TryConvertFromTruncating<TOther>(TOther value, out {{TypeNameT}} result) where TOther : INumberBase<TOther>
    {
        if (value is {{TypeNameT}} v)
        {
            result = v;
            return true;
        }

        if (value is IVec{{vecN}} IVec{{vecN}} && IVec{{vecN}}.GetTruncating<T>() is {} r)
        {
            result = r;
            return true;
        }

        result = default;
        return false;
    }

    public static bool TryConvertToChecked<TOther>({{TypeNameT}} value, [MaybeNullWhen(false)] out TOther result) where TOther : INumberBase<TOther>
    {
        return TOther.TryConvertFromChecked(value, out result);
    }

    public static bool TryConvertToSaturating<TOther>({{TypeNameT}} value, [MaybeNullWhen(false)] out TOther result) where TOther : INumberBase<TOther>
    {
        return TOther.TryConvertFromSaturating(value, out result);
    }

    public static bool TryConvertToTruncating<TOther>({{TypeNameT}} value, [MaybeNullWhen(false)]out TOther result) where TOther : INumberBase<TOther>
    {
        return TOther.TryConvertFromTruncating(value, out result);
    }

    static int INumberBase<{{TypeNameT}}>.Radix => T.Radix;

    {{~
    func repeatForComponentsWithOffsetAndPutInMiddle(left = '', right = '', startOffset = 0, sep = ', ')
        arr = []
        for x in startOffset..dimensionIndex
            arr = arr | array.add $"{left}{Components[x]}{right}"
        end
        ret arr | array.join sep
    end
    ~}}

    {{TypeName}}<T1>? IVec{{vecN}}.GetChecked<T1>() => T1.TryConvertFromChecked(X, out var x) ? new(x, {{ repeatForComponentsWithOffsetAndPutInMiddle 'T1.CreateChecked(' ')' startOffset:1 }}) : null;
    {{TypeName}}<T1>? IVec{{vecN}}.GetSaturating<T1>() => T1.TryConvertFromSaturating(X, out var x) ? new(x, {{ repeatForComponentsWithOffsetAndPutInMiddle 'T1.CreateSaturating(' ')' startOffset:1 }}) : null;
    {{TypeName}}<T1>? IVec{{vecN}}.GetTruncating<T1>() => T1.TryConvertFromTruncating(X, out var x) ? new(x, {{ repeatForComponentsWithOffsetAndPutInMiddle 'T1.CreateTruncating(' ')' startOffset:1 }}) : null;
}

// {{ TypeNameT }}.IReadOnlyList
public readonly partial struct {{ TypeNameT }} : IReadOnlyList<T>
{
    IEnumerator<T> IEnumerable<T>.GetEnumerator()
    {
        {{~ for x in 0..dimensionIndex ~}}
        yield return {{ Components[x] }};
        {{~ end ~}}
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return ((IEnumerable<T>)this).GetEnumerator();
    }

    int IReadOnlyCollection<T>.Count => Count;

}

// {{ TypeNameT }}.IUtf8SpanParsableFormattable
public partial struct {{ TypeNameT }} :
    IUtf8SpanFormattable,
    IUtf8SpanParsable<{{ TypeNameT }}>
{
    public bool TryFormat(Span<byte> utf8Destination, out int bytesWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        // Possible fast path for failure case:
        // if (destination.Length < 4) return false;

        var separator = NumberFormatInfo.GetInstance(provider).NumberGroupSeparator;

        // We can't use an interpolated string here because it won't allow us to pass `format`
        var handler = new Utf8.TryWriteInterpolatedStringHandler(
            4 + (separator.Length * 2),
            Count,
            utf8Destination,
            provider,
            out var shouldAppend
        );
        if (!shouldAppend)
        {
            bytesWritten = 0;
            return false;
        }

        // Annoyingly we need to turn the span into a string for the string handler
        string? formatString = format.Length > 0 ? new string(format) : null;

        // JIT will automagically convert literals to utf8
        _ =
            handler.AppendLiteral("<") &&
            {{~ for x in 0..dimensionIndex ~}}
            handler.AppendFormatted({{ Components[x] }}, formatString) &&
                {{~ if x < dimensionIndex ~}}
            handler.AppendLiteral(separator) &&
            handler.AppendLiteral(" ") &&
                {{~ end ~}}
            {{~ end ~}}
            handler.AppendLiteral(">");

        return Utf8.TryWrite(utf8Destination, ref handler, out bytesWritten);
    }

    public static {{ TypeNameT }} Parse(ReadOnlySpan<byte> utf8Text, IFormatProvider? provider)
        => TryParse(utf8Text, provider, out var result) ? result : throw new ArgumentException($"Failed to parse {nameof({{TypeName}})}<{typeof(T)}>");

    public static bool TryParse(ReadOnlySpan<byte> s, IFormatProvider? provider, out {{ TypeNameT }} result)
    {
        result = default;

        if (s[0] != (byte)'<') return false;
        if (s[^1] != (byte)'>') return false;

        var separator = NumberGroupSeparatorTChar<byte>(NumberFormatInfo.GetInstance(provider));

        s = s[1..^1];

        T? {{ Components | array.limit vecN | array.join ', ' | string.downcase }};

        {{~ for x in 0..<(vecN - 1) ~}}
        {
            if (s.Length == 0) return false;

            var nextNumber = s.IndexOf(separator);
            if (nextNumber == -1)
            {
                return false;
            }

            if (!T.TryParse(s[..nextNumber], provider, out {{ Components[x] | string.downcase }})) return false;

            s = s[(nextNumber + separator.Length)..];
        }
        {{~ end ~}}

        {
            if (s.Length == 0) return false;

            if (!T.TryParse(s, provider, out {{ Components[vecN-1] | string.downcase }})) return false;
        }

        result = new {{TypeNameT}}({{ Components | array.limit vecN | array.join ', ' | string.downcase }});
        return true;

        [UnsafeAccessor(UnsafeAccessorKind.Method, Name = nameof(NumberGroupSeparatorTChar))]
        static extern ReadOnlySpan<TChar> NumberGroupSeparatorTChar<TChar>(NumberFormatInfo? c) where TChar : unmanaged;
    }
}

// {{ TypeName }}
public static partial class {{ TypeName }}
{
    #region Extension

    /// <summary>Returns the length of this vector object.</summary>
    /// <returns>The vector's length.</returns>
    /// <altmember cref="LengthSquared{T,TReturn}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TReturn Length<T, TReturn>(this {{ TypeNameT }} vec) where T : INumberBase<T> where TReturn : INumberBase<TReturn>, IRootFunctions<TReturn>
    {
        var lengthSquared = vec.LengthSquared<T, TReturn>();
        return TReturn.Sqrt(lengthSquared);
    }

    /// <summary>Returns the length of the vector squared.</summary>
    /// <returns>The vector's length squared.</returns>
    /// <remarks>This operation offers better performance than a call to the <see cref="Length{T,TReturn}" /> method.</remarks>
    /// <altmember cref="Length{T,TReturn}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TReturn LengthSquared<T, TReturn>(this {{ TypeNameT }} vec) where T : INumberBase<T> where TReturn : INumberBase<TReturn>
    {
        return Dot<T, TReturn>(vec, vec);
    }

    #endregion

    #region Basic

    /// <summary>Returns a new vector whose values are the product of each pair of elements in two specified vectors.</summary>
    /// <param name="left">The first vector.</param>
    /// <param name="right">The second vector.</param>
    /// <returns>The element-wise product vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Multiply<T>({{ TypeNameT }} left, {{ TypeNameT }} right) where T : INumberBase<T>
    {
        return left * right;
    }

    /// <summary>Multiplies a vector by a specified scalar.</summary>
    /// <param name="left">The vector to multiply.</param>
    /// <param name="right">The scalar value.</param>
    /// <returns>The scaled vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Multiply<T>({{ TypeNameT }} left, T right) where T : INumberBase<T>
    {
        return left * right;
    }

    /// <summary>Multiplies a scalar value by a specified vector.</summary>
    /// <param name="left">The scaled value.</param>
    /// <param name="right">The vector.</param>
    /// <returns>The scaled vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Multiply<T>(T left, {{ TypeNameT }} right) where T : INumberBase<T>
    {
        return left * right;
    }

    /// <summary>Negates a specified vector.</summary>
    /// <param name="value">The vector to negate.</param>
    /// <returns>The negated vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Negate<T>({{ TypeNameT }} value) where T : INumberBase<T>
    {
        return -value;
    }

    /// <summary>Subtracts the second vector from the first.</summary>
    /// <param name="left">The first vector.</param>
    /// <param name="right">The second vector.</param>
    /// <returns>The difference vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Subtract<T>({{ TypeNameT }} left, {{ TypeNameT }} right) where T : INumberBase<T>
    {
        return left - right;
    }

    /// <summary>Adds two vectors together.</summary>
    /// <param name="left">The first vector to add.</param>
    /// <param name="right">The second vector to add.</param>
    /// <returns>The summed vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Add<T>({{ TypeNameT }} left, {{ TypeNameT }} right) where T : INumberBase<T>
    {
        return left + right;
    }

    /// <summary>Divides the first vector by the second.</summary>
    /// <param name="left">The first vector.</param>
    /// <param name="right">The second vector.</param>
    /// <returns>The vector resulting from the division.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Divide<T>({{ TypeNameT }} left, {{ TypeNameT }} right) where T : INumberBase<T>
    {
        return left / right;
    }

    /// <summary>Divides the specified vector by a specified scalar value.</summary>
    /// <param name="left">The vector.</param>
    /// <param name="divisor">The scalar value.</param>
    /// <returns>The vector that results from the division.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Divide<T>({{ TypeNameT }} left, T divisor) where T : INumberBase<T>
    {
        return left / divisor;
    }

    #endregion

    #region Other

    /// <summary>Returns a vector whose elements are the absolute values of each of the specified vector's elements.</summary>
    /// <param name="value">A vector.</param>
    /// <returns>The absolute value vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Abs<T>({{ TypeNameT }} value) where T : INumberBase<T> => new({{ repeatCall 'T.Abs' 'value' }});

    /// <summary>Restricts a vector between a minimum and a maximum value.</summary>
    /// <param name="value1">The vector to restrict.</param>
    /// <param name="min">The minimum value.</param>
    /// <param name="max">The maximum value.</param>
    /// <returns>The restricted vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Clamp<T>({{ TypeNameT }} value1, {{ TypeNameT }} min, {{ TypeNameT }} max) where T : INumberBase<T>, IComparisonOperators<T, T, bool>
    {
        // We must follow HLSL behavior in the case user specified min value is bigger than max value.
        return Min(Max(value1, min), max);
    }

    /// <summary>Computes the Euclidean distance between the two given points.</summary>
    /// <param name="value1">The first point.</param>
    /// <param name="value2">The second point.</param>
    /// <returns>The distance.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TReturn Distance<T, TReturn>({{ TypeNameT }} value1, {{ TypeNameT }} value2) where T : INumberBase<T> where TReturn : INumberBase<TReturn>, IRootFunctions<TReturn>
    {
        var distanceSquared = DistanceSquared<T, TReturn>(value1, value2);
        return TReturn.Sqrt(distanceSquared);
    }

    /// <summary>Returns the Euclidean distance squared between two specified points.</summary>
    /// <param name="value1">The first point.</param>
    /// <param name="value2">The second point.</param>
    /// <returns>The distance squared.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T DistanceSquared<T>({{ TypeNameT }} value1, {{ TypeNameT }} value2) where T : INumberBase<T>
    {
        var difference = value1 - value2;
        return Dot(difference, difference);
    }

    /// <summary>Returns the Euclidean distance squared between two specified points.</summary>
    /// <param name="value1">The first point.</param>
    /// <param name="value2">The second point.</param>
    /// <returns>The distance squared.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TReturn DistanceSquared<T, TReturn>({{ TypeNameT }} value1, {{ TypeNameT }} value2) where T : INumberBase<T> where TReturn : INumberBase<TReturn>
    {
        var difference = value1 - value2;
        return Dot<T, TReturn>(difference, difference);
    }

    /// <summary>Returns the dot product of two vectors.</summary>
    /// <param name="vector1">The first vector.</param>
    /// <param name="vector2">The second vector.</param>
    /// <returns>The dot product.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Dot<T>({{ TypeNameT }} vector1, {{ TypeNameT }} vector2) where T : INumberBase<T>
    {
        return {{ for x in 0..dimensionIndex ~}} {{ operation x 'vector1' '*' 'vector2' ' + ' }} {{~ end -}};
    }

    /// <summary>Returns the dot product of two vectors.</summary>
    /// <param name="vector1">The first vector.</param>
    /// <param name="vector2">The second vector.</param>
    /// <returns>The dot product.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TReturn Dot<T, TReturn>({{ TypeNameT }} vector1, {{ TypeNameT }} vector2) where T : INumberBase<T> where TReturn : INumberBase<TReturn>
    {
        return {{ for x in 0..dimensionIndex ~}} {{ complexOperation x 'TReturn.CreateTruncating(vector1.' ')' '*' 'TReturn.CreateTruncating(vector2.' ')' ' + ' }} {{~ end -}};
    }

    /// <summary>Performs a linear interpolation between two vectors based on the given weighting.</summary>
    /// <param name="value1">The first vector.</param>
    /// <param name="value2">The second vector.</param>
    /// <param name="amount">A value between 0 and 1 that indicates the weight of <paramref name="value2" />.</param>
    /// <returns>The interpolated vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeName }}<TFloat> Lerp<T, TFloat>({{ TypeNameT }} value1, {{ TypeNameT }} value2, TFloat amount) where T : INumberBase<T> where TFloat : INumberBase<TFloat>, IFloatingPoint<TFloat>
    {
        return (value1.As<TFloat>() * (TFloat.One - amount)) + (value2.As<TFloat>() * amount);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeName }}<TFloat> LerpClamped<T, TFloat>({{ TypeNameT }} value1, {{ TypeNameT }} value2, TFloat amount) where T : INumberBase<T> where TFloat : INumberBase<TFloat>, IFloatingPoint<TFloat>
    {
        amount = TFloat.Clamp(amount, TFloat.Zero, TFloat.One);
        return Lerp(value1, value2, amount);
    }

    /// <summary>Returns a vector whose elements are the maximum of each of the pairs of elements in two specified vectors.</summary>
    /// <param name="value1">The first vector.</param>
    /// <param name="value2">The second vector.</param>
    /// <returns>The maximized vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Max<T>({{ TypeNameT }} value1, {{ TypeNameT }} value2) where T : INumberBase<T>, IComparisonOperators<T, T, bool>
    {
        return new {{ TypeNameT }}( // using T.Max here would add an IsNaN check
        {{~ for x in 0..dimensionIndex ~}}
            (value1.{{Components[x]}} > value2.{{Components[x]}}) ? value1.{{Components[x]}} : value2.{{Components[x]}} {{- if x < dimensionIndex }},{{ end }}
        {{~ end ~}}
        );
    }

    /// <summary>Returns a vector whose elements are the minimum of each of the pairs of elements in two specified vectors.</summary>
    /// <param name="value1">The first vector.</param>
    /// <param name="value2">The second vector.</param>
    /// <returns>The minimized vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Min<T>({{ TypeNameT }} value1, {{ TypeNameT }} value2) where T : INumberBase<T>, IComparisonOperators<T, T, bool>
    {
        return new {{ TypeNameT }}( // using T.Min here would add an IsNaN check
        {{~ for x in 0..dimensionIndex ~}}
            (value1.{{Components[x]}} < value2.{{Components[x]}}) ? value1.{{Components[x]}} : value2.{{Components[x]}} {{- if x < dimensionIndex }},{{ end }}
        {{~ end ~}}
        );
    }

    /// <summary>Returns a vector with the same direction as the specified vector, but with a length of one.</summary>
    /// <param name="value">The vector to normalize.</param>
    /// <returns>The normalized vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeName }}<TReturn> Normalize<T, TReturn>({{ TypeNameT }} value) where T : INumberBase<T> where TReturn : INumberBase<TReturn>, IRootFunctions<TReturn>
    {
        return value.As<TReturn>() / value.Length<T, TReturn>();
    }

    /// <summary>Returns a vector with the same direction as the specified vector, but with a length of one.</summary>
    /// <param name="value">The vector to normalize.</param>
    /// <returns>The normalized vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Normalize<T>({{ TypeNameT }} value) where T : INumberBase<T>, IRootFunctions<T>
    {
        return value / value.Length();
    }

    /// <summary>Returns the reflection of a vector off a surface that has the specified normal.</summary>
    /// <param name="vector">The source vector.</param>
    /// <param name="normal">The normal of the surface being reflected off.</param>
    /// <returns>The reflected vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeName }}<TReturn> Reflect<T, TReturn>({{ TypeNameT }} vector, {{ TypeNameT }} normal) where T : INumberBase<T> where TReturn : INumberBase<TReturn>
    {
        var dot = Dot<T, TReturn>(vector, normal);
        return vector.As<TReturn>() - (NumericConstants<TReturn>.Two * (dot * normal.As<TReturn>()));
    }

    /// <summary>Returns a vector whose elements are the square root of each of a specified vector's elements.</summary>
    /// <param name="value">A vector.</param>
    /// <returns>The square root vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeName }}<TReturn> Sqrt<T, TReturn>({{ TypeNameT }} value) where T : INumberBase<T> where TReturn : INumberBase<TReturn>, IRootFunctions<TReturn>
    {
        return new {{ TypeName }}<TReturn>(
        {{~ for x in 0..dimensionIndex ~}}
            TReturn.Sqrt(TReturn.CreateTruncating(value.{{Components[x]}})) {{- if x < dimensionIndex }},{{ end }}
        {{~ end ~}}
        );
    }

    /// <summary>Transforms a vector by a specified 4x4 matrix.</summary>
    /// <param name="position">The vector to transform.</param>
    /// <param name="matrix">The transformation matrix.</param>
    /// <returns>The transformed vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Transform<T>({{ TypeNameT }} position, Matrix4X4<T> matrix) where T : INumberBase<T>
    {
        return ({{ TypeNameT }})Vector4D.Transform(position, matrix);
    }

    /// <summary>Transforms a vector by the specified Quaternion rotation value.</summary>
    /// <param name="value">The vector to rotate.</param>
    /// <param name="rotation">The rotation to apply.</param>
    /// <returns>The transformed vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeName }}<TReturn> Transform<T, TQuat, TReturn>({{ TypeNameT }} value, Quaternion<TQuat> rotation) where T : INumberBase<T> where TReturn : INumberBase<TReturn> where TQuat : ITrigonometricFunctions<TQuat>, IRootFunctions<TQuat>
    {
        var x2 = rotation.X + rotation.X;
        var y2 = rotation.Y + rotation.Y;
        var z2 = rotation.Z + rotation.Z;

        var wx2 = TReturn.CreateTruncating(rotation.W * x2);
        var wy2 = TReturn.CreateTruncating(rotation.W * y2);
        var wz2 = TReturn.CreateTruncating(rotation.W * z2);
        var xx2 = TReturn.CreateTruncating(rotation.X * x2);
        var xy2 = TReturn.CreateTruncating(rotation.X * y2);
        var xz2 = TReturn.CreateTruncating(rotation.X * z2);
        var yy2 = TReturn.CreateTruncating(rotation.Y * y2);
        var yz2 = TReturn.CreateTruncating(rotation.Y * z2);
        var zz2 = TReturn.CreateTruncating(rotation.Z * z2);

        return new {{ TypeName }}<TReturn>(
            TReturn.CreateTruncating(value.X) * (TReturn.One - yy2 - zz2) + TReturn.CreateTruncating(value.Y) * (xy2 - wz2) + TReturn.CreateTruncating(value.Z) * (xz2 + wy2),
            TReturn.CreateTruncating(value.X) * (xy2 + wz2) + TReturn.CreateTruncating(value.Y) * (TReturn.One - xx2 - zz2) + TReturn.CreateTruncating(value.Z) * (yz2 - wx2),
            TReturn.CreateTruncating(value.X) * (xz2 - wy2) + TReturn.CreateTruncating(value.Y) * (yz2 + wx2) + TReturn.CreateTruncating(value.Z) * (TReturn.One - xx2 - yy2)
        );
    }

    // /// <summary>Transforms a vector normal by the given 4x4 matrix.</summary>
    // /// <param name="normal">The source vector.</param>
    // /// <param name="matrix">The matrix.</param>
    // /// <returns>The transformed vector.</returns>
    // [MethodImpl(MethodImplOptions.AggressiveInlining)]
    // internal static {{ TypeNameT }} TransformNormal<T>({{ TypeNameT }} normal, in Matrix4x4 matrix) where T : INumberBase<T>
    // {
    //     var matrixX = new Vector4(matrix.M11, matrix.M12, matrix.M13, matrix.M14);
    //     var matrixY = new Vector4(matrix.M21, matrix.M22, matrix.M23, matrix.M24);
    //     var matrixZ = new Vector4(matrix.M31, matrix.M32, matrix.M33, matrix.M34);
    //     // var matrixW = new Vector4(matrix.M41, matrix.M42, matrix.M43, matrix.M44);
    //
    //     var result = matrixX * normal.X;
    //     result += matrixY * normal.Y;
    //     result += matrixZ * normal.Z;
    //     return result.AsVector128().AsVector3();
    // }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Remainder<T>(this {{ TypeNameT }} left, {{ TypeNameT }} right) where T : INumberBase<T>, IModulusOperators<T, T, T>
    {
        return new {{ TypeNameT }}(
            left.X % right.X,
            left.Y % right.Y,
            left.Z % right.Z
        );
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Remainder<T>(this {{ TypeNameT }} left, T right) where T : INumberBase<T>, IModulusOperators<T, T, T>
    {
        return new {{ TypeNameT }}(
            left.X % right,
            left.Y % right,
            left.Z % right
        );
    }
    #endregion

    #region Specializations

    /// <summary>Returns the length of this vector object.</summary>
    /// <returns>The vector's length.</returns>
    /// <altmember cref="LengthSquared{T}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Length<T>(this {{ TypeNameT }} vec) where T : INumberBase<T>, IRootFunctions<T>
    {
        return vec.Length<T, T>();
    }

    /// <summary>Returns the length of the vector squared.</summary>
    /// <returns>The vector's length squared.</returns>
    /// <remarks>This operation offers better performance than a call to the <see cref="Length{T}" /> method.</remarks>
    /// <altmember cref="Length{T}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T LengthSquared<T>(this {{ TypeNameT }} vec) where T : INumberBase<T>
    {
        return vec.LengthSquared<T, T>();
    }

    /// <summary>Performs a linear interpolation between two vectors based on the given weighting.</summary>
    /// <param name="value1">The first vector.</param>
    /// <param name="value2">The second vector.</param>
    /// <param name="amount">A value between 0 and 1 that indicates the weight of <paramref name="value2" />.</param>
    /// <returns>The interpolated vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Lerp<T>({{ TypeNameT }} value1, {{ TypeNameT }} value2, T amount) where T : INumberBase<T>, IFloatingPoint<T>
    {
        return Lerp<T, T>(value1, value2, amount);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} LerpClamped<T>({{ TypeNameT }} value1, {{ TypeNameT }} value2, T amount) where T : INumberBase<T>, IFloatingPoint<T>
    {
        return LerpClamped<T, T>(value1, value2, amount);
    }

    /// <summary>Returns the reflection of a vector off a surface that has the specified normal.</summary>
    /// <param name="vector">The source vector.</param>
    /// <param name="normal">The normal of the surface being reflected off.</param>
    /// <returns>The reflected vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Reflect<T>({{ TypeNameT }} vector, {{ TypeNameT }} normal) where T : IFloatingPoint<T>
    {
        return Reflect<T, T>(vector, normal);
    }

    /// <summary>Returns a vector whose elements are the square root of each of a specified vector's elements.</summary>
    /// <param name="value">A vector.</param>
    /// <returns>The square root vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Sqrt<T>({{ TypeNameT }} value) where T : IFloatingPoint<T>, IRootFunctions<T>
    {
        return Sqrt<T, T>(value);
    }

    /// <summary>Transforms a vector by the specified Quaternion rotation value.</summary>
    /// <param name="value">The vector to rotate.</param>
    /// <param name="rotation">The rotation to apply.</param>
    /// <returns>The transformed vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Transform<T>({{ TypeNameT }} value, Quaternion<T> rotation)
        where T : IFloatingPoint<T>, ITrigonometricFunctions<T>, IRootFunctions<T>
    {
        return Transform<T, T, T>(value, rotation);
    }


    /// <summary>Transforms a vector by the specified Quaternion rotation value.</summary>
    /// <param name="value">The vector to rotate.</param>
    /// <param name="rotation">The rotation to apply.</param>
    /// <returns>The transformed vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{ TypeNameT }} Transform<T, TQuat>({{ TypeNameT }} value, Quaternion<TQuat> rotation)
        where T : IFloatingPoint<T>
        where TQuat : ITrigonometricFunctions<TQuat>, IRootFunctions<TQuat>
    {
        return Transform<T, TQuat, T>(value, rotation);
    }
    #endregion

    // Equivalent implementing IHyperbolicFunctions<System.Runtime.Intrinsics.Vector3>
    public static {{ TypeNameT }} Acosh<T>({{ TypeNameT }} x) where T : IHyperbolicFunctions<T> => new(T.Acosh(x.X), T.Acosh(x.Y), T.Acosh(x.Z));
    public static {{ TypeNameT }} Asinh<T>({{ TypeNameT }} x) where T : IHyperbolicFunctions<T> => new(T.Asinh(x.X), T.Asinh(x.Y), T.Asinh(x.Z));
    public static {{ TypeNameT }} Atanh<T>({{ TypeNameT }} x) where T : IHyperbolicFunctions<T> => new(T.Atanh(x.X), T.Atanh(x.Y), T.Atanh(x.Z));
    public static {{ TypeNameT }} Cosh<T>({{ TypeNameT }} x) where T : IHyperbolicFunctions<T> => new(T.Cosh(x.X), T.Cosh(x.Y), T.Cosh(x.Z));
    public static {{ TypeNameT }} Sinh<T>({{ TypeNameT }} x) where T : IHyperbolicFunctions<T> => new(T.Sinh(x.X), T.Sinh(x.Y), T.Sinh(x.Z));
    public static {{ TypeNameT }} Tanh<T>({{ TypeNameT }} x) where T : IHyperbolicFunctions<T> => new(T.Tanh(x.X), T.Tanh(x.Y), T.Tanh(x.Z));

    // Equivalent implementing ITrigonometricFunctions<System.Runtime.Intrinsics.Vector3>
    public static {{ TypeNameT }} Acos<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T> => new(T.Acos(x.X), T.Acos(x.Y), T.Acos(x.Z));
    public static {{ TypeNameT }} AcosPi<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T> => new(T.AcosPi(x.X), T.AcosPi(x.Y), T.AcosPi(x.Z));
    public static {{ TypeNameT }} Asin<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T> => new(T.Asin(x.X), T.Asin(x.Y), T.Asin(x.Z));
    public static {{ TypeNameT }} AsinPi<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T> => new(T.AsinPi(x.X), T.AsinPi(x.Y), T.AsinPi(x.Z));
    public static {{ TypeNameT }} Atan<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T> => new(T.Atan(x.X), T.Atan(x.Y), T.Atan(x.Z));
    public static {{ TypeNameT }} AtanPi<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T> => new(T.AtanPi(x.X), T.AtanPi(x.Y), T.AtanPi(x.Z));
    public static {{ TypeNameT }} Cos<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T> => new(T.Cos(x.X), T.Cos(x.Y), T.Cos(x.Z));
    public static {{ TypeNameT }} CosPi<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T> => new(T.CosPi(x.X), T.CosPi(x.Y), T.CosPi(x.Z));
    public static {{ TypeNameT }} DegreesToRadians<T>({{ TypeNameT }} degrees) where T : ITrigonometricFunctions<T> => new(T.DegreesToRadians(degrees.X), T.DegreesToRadians(degrees.Y), T.DegreesToRadians(degrees.Z));
    public static {{ TypeNameT }} RadiansToDegrees<T>({{ TypeNameT }} radians) where T : ITrigonometricFunctions<T> => new(T.RadiansToDegrees(radians.X), T.RadiansToDegrees(radians.Y), T.RadiansToDegrees(radians.Z));
    public static {{ TypeNameT }} Sin<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T> => new(T.Sin(x.X), T.Sin(x.Y), T.Sin(x.Z));
    public static {{ TypeNameT }} SinPi<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T> => new(T.SinPi(x.X), T.SinPi(x.Y), T.SinPi(x.Z));
    public static {{ TypeNameT }} Tan<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T> => new(T.Tan(x.X), T.Tan(x.Y), T.Tan(x.Z));
    public static {{ TypeNameT }} TanPi<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T> => new(T.TanPi(x.X), T.TanPi(x.Y), T.TanPi(x.Z));


    public static ({{ TypeNameT }} Sin, {{ TypeNameT }} Cos) SinCos<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T>
    {
        var (sinX, cosX) = T.SinCos(x.X);
        var (sinY, cosY) = T.SinCos(x.Y);
        var (sinZ, cosZ) = T.SinCos(x.Z);

        return (new {{ TypeNameT }}(sinX, sinY, sinZ), new {{ TypeNameT }}(cosX, cosY, cosZ));
    }

    public static ({{ TypeNameT }} SinPi, {{ TypeNameT }} CosPi) SinCosPi<T>({{ TypeNameT }} x) where T : ITrigonometricFunctions<T>
    {
        var (sinX, cosX) = T.SinCosPi(x.X);
        var (sinY, cosY) = T.SinCosPi(x.Y);
        var (sinZ, cosZ) = T.SinCosPi(x.Z);

        return (new {{ TypeNameT }}(sinX, sinY, sinZ), new {{ TypeNameT }}(cosX, cosY, cosZ));
    }

    // Equivalent implementing ILogarithmicFunctions<System.Runtime.Intrinsics.Vector3>
    public static {{ TypeNameT }} Log<T>({{ TypeNameT }} x) where T : ILogarithmicFunctions<T> => new(T.Log(x.X), T.Log(x.Y), T.Log(x.Z));
    public static {{ TypeNameT }} Log<T>({{ TypeNameT }} x, {{ TypeNameT }} newBase) where T : ILogarithmicFunctions<T> => new(T.Log(x.X, newBase.X), T.Log(x.Y, newBase.Y), T.Log(x.Z, newBase.Z));
    public static {{ TypeNameT }} Log<T>({{ TypeNameT }} x, T newBase) where T : ILogarithmicFunctions<T> => new(T.Log(x.X, newBase), T.Log(x.Y, newBase), T.Log(x.Z, newBase));
    public static {{ TypeNameT }} LogP1<T>({{ TypeNameT }} x) where T : ILogarithmicFunctions<T> => Log(x + {{ TypeNameT }}.One);
    public static {{ TypeNameT }} Log2<T>({{ TypeNameT }} x) where T : ILogarithmicFunctions<T> => new(T.Log2(x.X), T.Log2(x.Y), T.Log2(x.Z));
    public static {{ TypeNameT }} Log2P1<T>({{ TypeNameT }} x) where T : ILogarithmicFunctions<T> => Log2(x + {{ TypeNameT }}.One);
    public static {{ TypeNameT }} Log10<T>({{ TypeNameT }} x) where T : ILogarithmicFunctions<T> => new(T.Log10(x.X), T.Log10(x.Y), T.Log10(x.Z));
    public static {{ TypeNameT }} Log10P1<T>({{ TypeNameT }} x) where T : ILogarithmicFunctions<T> => Log10(x + {{ TypeNameT }}.One);

    // Equivalent implementing IExponentialFunctions<System.Runtime.Intrinsics.Vector3>
    public static {{ TypeNameT }} Exp<T>({{ TypeNameT }} x) where T : IExponentialFunctions<T> => new(T.Exp(x.X), T.Exp(x.Y), T.Exp(x.Z));
    public static {{ TypeNameT }} ExpM1<T>({{ TypeNameT }} x) where T : IExponentialFunctions<T> => Exp(x) - {{ TypeNameT }}.One;
    public static {{ TypeNameT }} Exp2<T>({{ TypeNameT }} x) where T : IExponentialFunctions<T> => new(T.Exp2(x.X), T.Exp2(x.Y), T.Exp2(x.Z));
    public static {{ TypeNameT }} Exp2M1<T>({{ TypeNameT }} x) where T : IExponentialFunctions<T> => Exp2(x) - {{ TypeNameT }}.One;
    public static {{ TypeNameT }} Exp10<T>({{ TypeNameT }} x) where T : IExponentialFunctions<T> => new(T.Exp10(x.X), T.Exp10(x.Y), T.Exp10(x.Z));
    public static {{ TypeNameT }} Exp10M1<T>({{ TypeNameT }} x) where T : IExponentialFunctions<T> => Exp10(x) - {{ TypeNameT }}.One;

    // Equivalent implementing IPowerFunctions<System.Runtime.Intrinsics.Vector3>
    public static {{ TypeNameT }} Pow<T>({{ TypeNameT }} x, {{ TypeNameT }} y) where T : IPowerFunctions<T> => new(T.Pow(x.X, y.X), T.Pow(x.Y, y.Y), T.Pow(x.Z, y.Z));
    public static {{ TypeNameT }} Pow<T>({{ TypeNameT }} x, T y) where T : IPowerFunctions<T> => new(T.Pow(x.X, y), T.Pow(x.Y, y), T.Pow(x.Z, y));

    // Equivalent implementing IRootFunctions<System.Runtime.Intrinsics.Vector3>
    public static {{ TypeNameT }} Cbrt<T>({{ TypeNameT }} x) where T : IRootFunctions<T> => new(T.Cbrt(x.X), T.Cbrt(x.Y), T.Cbrt(x.Z));
    public static {{ TypeNameT }} Hypot<T>({{ TypeNameT }} x, {{ TypeNameT }} y) where T : IRootFunctions<T> => new(T.Hypot(x.X, y.X), T.Hypot(x.Y, y.Y), T.Hypot(x.Z, y.Z));
    public static {{ TypeNameT }} Hypot<T>({{ TypeNameT }} x, T y) where T : IRootFunctions<T> => new(T.Hypot(x.X, y), T.Hypot(x.Y, y), T.Hypot(x.Z, y));
    public static {{ TypeNameT }} RootN<T>({{ TypeNameT }} x, int n) where T : IRootFunctions<T> => new(T.RootN(x.X, n), T.RootN(x.Y, n), T.RootN(x.Z, n));

    // IFloatingPoint<TSelf>
    public static {{ TypeNameT }} Round<T>({{ TypeNameT }} x) where T : IFloatingPoint<T> => new(T.Round(x.X), T.Round(x.Y), T.Round(x.Z));
    public static {{ TypeNameT }} Round<T>({{ TypeNameT }} x, int digits) where T : IFloatingPoint<T> => new(T.Round(x.X, digits), T.Round(x.Y, digits), T.Round(x.Z, digits));
    public static {{ TypeNameT }} Round<T>({{ TypeNameT }} x, MidpointRounding mode) where T : IFloatingPoint<T> => new(T.Round(x.X, mode), T.Round(x.Y, mode), T.Round(x.Z, mode));
    public static {{ TypeNameT }} Round<T>({{ TypeNameT }} x, int digits, MidpointRounding mode) where T : IFloatingPoint<T> => new(T.Round(x.X, digits, mode), T.Round(x.Y, digits, mode), T.Round(x.Z, digits, mode));
    public static {{ TypeNameT }} Truncate<T>({{ TypeNameT }} x) where T : IFloatingPoint<T> => new(T.Truncate(x.X), T.Truncate(x.Y), T.Truncate(x.Z));

    // IFloatingPointIeee754<TSelf>
    public static {{ TypeNameT }} Atan2<T>({{ TypeNameT }} x, {{ TypeNameT }} y) where T : IFloatingPointIeee754<T> => new(T.Atan2(x.X, y.X), T.Atan2(x.Y, y.Y), T.Atan2(x.Z, y.Z));
    public static {{ TypeNameT }} Atan2Pi<T>({{ TypeNameT }} x, {{ TypeNameT }} y) where T : IFloatingPointIeee754<T> => new(T.Atan2Pi(x.X, y.X), T.Atan2Pi(x.Y, y.Y), T.Atan2Pi(x.Z, y.Z));
    public static {{ TypeNameT }} Atan2<T>({{ TypeNameT }} x, T y) where T : IFloatingPointIeee754<T> => new(T.Atan2(x.X, y), T.Atan2(x.Y, y), T.Atan2(x.Z, y));
    public static {{ TypeNameT }} Atan2Pi<T>({{ TypeNameT }} x, T y) where T : IFloatingPointIeee754<T> => new(T.Atan2Pi(x.X, y), T.Atan2Pi(x.Y, y), T.Atan2Pi(x.Z, y));
    public static {{ TypeNameT }} BitDecrement<T>({{ TypeNameT }} x) where T : IFloatingPointIeee754<T> => new(T.BitDecrement(x.X), T.BitDecrement(x.Y), T.BitDecrement(x.Z));
    public static {{ TypeNameT }} BitIncrement<T>({{ TypeNameT }} x) where T : IFloatingPointIeee754<T> => new(T.BitIncrement(x.X), T.BitIncrement(x.Y), T.BitIncrement(x.Z));
    public static {{ TypeNameT }} FusedMultiplyAdd<T>({{ TypeNameT }} left, {{ TypeNameT }} right, {{ TypeNameT }} addend) where T : IFloatingPointIeee754<T> => new(T.FusedMultiplyAdd(left.X, right.X, addend.X), T.FusedMultiplyAdd(left.Y, right.Y, addend.Y), T.FusedMultiplyAdd(left.Z, right.Z, addend.Z));
    public static {{ TypeNameT }} Lerp<T>({{ TypeNameT }} value1, {{ TypeNameT }} value2, {{ TypeNameT }} amount) where T : IFloatingPointIeee754<T> => new(T.Lerp(value1.X, value2.X, amount.X), T.Lerp(value1.Y, value2.Y, amount.Y), T.Lerp(value1.Z, value2.Z, amount.Z));
    public static {{ TypeNameT }} ReciprocalEstimate<T>({{ TypeNameT }} x) where T : IFloatingPointIeee754<T> => new(T.ReciprocalEstimate(x.X), T.ReciprocalEstimate(x.Y), T.ReciprocalEstimate(x.Z));
    public static {{ TypeNameT }} ReciprocalSqrtEstimate<T>({{ TypeNameT }} x) where T : IFloatingPointIeee754<T> => new(T.ReciprocalSqrtEstimate(x.X), T.ReciprocalSqrtEstimate(x.Y), T.ReciprocalSqrtEstimate(x.Z));

    // INumber<T>
    // public static {{ TypeNameT }} Clamp<T>({{ TypeNameT }} value, {{ TypeNameT }} min, {{ TypeNameT }} max) where T : INumber<T> => new(T.Clamp(x.X), T.Clamp(x.Y), T.Clamp(x.Z));
    public static {{ TypeNameT }} CopySign<T>({{ TypeNameT }} value, {{ TypeNameT }} sign) where T : INumber<T> => new(T.CopySign(value.X, sign.X), T.CopySign(value.Y, sign.Y), T.CopySign(value.Z, sign.Z));
    public static {{ TypeNameT }} CopySign<T>({{ TypeNameT }} value, T sign) where T : INumber<T> => new(T.CopySign(value.X, sign), T.CopySign(value.Y, sign), T.CopySign(value.Z, sign));
    public static {{ TypeNameT }} MaxNumber<T>({{ TypeNameT }} x, {{ TypeNameT }} y) where T : INumber<T> => new(T.MaxNumber(x.X, y.X), T.MaxNumber(x.Y, y.Y), T.MaxNumber(x.Z, y.Z));
    public static {{ TypeNameT }} MinNumber<T>({{ TypeNameT }} x, {{ TypeNameT }} y) where T : INumber<T> => new(T.MinNumber(x.X, y.X), T.MinNumber(x.Y, y.Y), T.MinNumber(x.Z, y.Z));

    // INumberBase<T>
    // public static {{ TypeNameT }} MaxMagnitude<T>({{ TypeNameT }} x, {{ TypeNameT }} y) where T : INumberBase<T> => new(T.MaxMagnitude(x.X, y.X), T.MaxMagnitude(x.Y, y.Y), T.MaxMagnitude(x.Z, y.Z));
    // public static {{ TypeNameT }} MaxMagnitudeNumber<T>({{ TypeNameT }} x, {{ TypeNameT }} y) where T : INumberBase<T> => new(T.MaxMagnitudeNumber(x.X, y.X), T.MaxMagnitudeNumber(x.Y, y.Y), T.MaxMagnitudeNumber(x.Z, y.Z));
    // public static {{ TypeNameT }} MinMagnitude<T>({{ TypeNameT }} x, {{ TypeNameT }} y) where T : INumberBase<T> => new(T.MinMagnitude(x.X, y.X), T.MinMagnitude(x.Y, y.Y), T.MinMagnitude(x.Z, y.Z));
    // public static {{ TypeNameT }} MinMagnitudeNumber<T>({{ TypeNameT }} x, {{ TypeNameT }} y) where T : INumberBase<T> => new(T.MinMagnitudeNumber(x.X, y.X), T.MinMagnitudeNumber(x.Y, y.Y), T.MinMagnitudeNumber(x.Z, y.Z));
    // (there's no reason you would want these.)

    // IFloatingPointIeee754<TSelf>
    public static {{ TypeName }}<int> ILogB<T>({{ TypeNameT }} x) where T : IFloatingPointIeee754<T> => new(T.ILogB(x.X), T.ILogB(x.Y), T.ILogB(x.Z));
    public static {{ TypeNameT }} ScaleB<T>({{ TypeNameT }} x, {{ TypeName }}<int> n) where T : IFloatingPointIeee754<T> => new(T.ScaleB(x.X, n.X), T.ScaleB(x.Y, n.Y), T.ScaleB(x.Z, n.Z));
    public static {{ TypeNameT }} ScaleB<T>({{ TypeNameT }} x, int n) where T : IFloatingPointIeee754<T> => new(T.ScaleB(x.X, n), T.ScaleB(x.Y, n), T.ScaleB(x.Z, n));

    public static {{ TypeName }}<int> RoundToInt<T>({{ TypeNameT }} vector) where T : IFloatingPoint<T>
    {
        return new {{ TypeName }}<int>(
            int.CreateSaturating(T.Round(vector.X)),
            int.CreateSaturating(T.Round(vector.Y)),
            int.CreateSaturating(T.Round(vector.Z))
        );
    }

    public static {{ TypeName }}<int> FloorToInt<T>({{ TypeNameT }} vector) where T : IFloatingPoint<T>
    {
        return new {{ TypeName }}<int>(
            int.CreateSaturating(T.Floor(vector.X)),
            int.CreateSaturating(T.Floor(vector.Y)),
            int.CreateSaturating(T.Floor(vector.Z))
        );
    }

    public static {{ TypeName }}<int> CeilingToInt<T>({{ TypeNameT }} vector) where T : IFloatingPoint<T>
    {
        return new {{ TypeName }}<int>(
            int.CreateSaturating(T.Ceiling(vector.X)),
            int.CreateSaturating(T.Ceiling(vector.Y)),
            int.CreateSaturating(T.Ceiling(vector.Z))
        );
    }

    public static {{ TypeName }}<TInt> RoundToInt<T, TInt>({{ TypeNameT }} vector) where T : IFloatingPoint<T> where TInt : IBinaryInteger<TInt>
    {
        return new {{ TypeName }}<TInt>(
            TInt.CreateSaturating(T.Round(vector.X)),
            TInt.CreateSaturating(T.Round(vector.Y)),
            TInt.CreateSaturating(T.Round(vector.Z))
        );
    }

    public static {{ TypeName }}<TInt> FloorToInt<T, TInt>({{ TypeNameT }} vector) where T : IFloatingPoint<T> where TInt : IBinaryInteger<TInt>
    {
        return new {{ TypeName }}<TInt>(
            TInt.CreateSaturating(T.Floor(vector.X)),
            TInt.CreateSaturating(T.Floor(vector.Y)),
            TInt.CreateSaturating(T.Floor(vector.Z))
        );
    }

    public static {{ TypeName }}<TInt> CeilingToInt<T, TInt>({{ TypeNameT }} vector) where T : IFloatingPoint<T> where TInt : IBinaryInteger<TInt>
    {
        return new {{ TypeName }}<TInt>(
            TInt.CreateSaturating(T.Ceiling(vector.X)),
            TInt.CreateSaturating(T.Ceiling(vector.Y)),
            TInt.CreateSaturating(T.Ceiling(vector.Z))
        );
    }

    public static {{ TypeName }}<float> AsGeneric(this Vector3 vector)
        => Unsafe.BitCast<Vector3, {{ TypeName }}<float>>(vector);

    public static Vector3 AsNumerics(this {{ TypeName }}<float> vector)
        => Unsafe.BitCast<{{ TypeName }}<float>, Vector3>(vector);
}

{{ end }}